{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Portafolio Ibero","text":"<p>Bienvenido  Esta es mi Portafolio para cursos y proyectos a lo largo de mi Carrera.</p>"},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/","title":"Pr\u00e1cticas \u2013 Control de Motores DC con ESP32 y Puente H","text":""},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#practica-1-control-de-direccion-de-un-motor-dc-con-esp32-y-puente-h","title":"Pr\u00e1ctica 1 \u2013 Control de direcci\u00f3n de un motor DC con ESP32 y puente H","text":""},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#1-resumen","title":"1) Resumen","text":"<p>Nombre del proyecto: Control de Direcci\u00f3n de Motor DC  </p> <p>Equipo / Autor(es):  Jos\u00e9 Ismael Guerrero Rom\u00e1n y Gerardo Esquivel De Luna </p> <p>Curso / Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica </p> <p>Fecha:   03/oct/25</p> <p>Descripci\u00f3n breve: Se control\u00f3 un motor de corriente directa (DC) mediante un ESP32 y un puente H (L298N), alternando su sentido de giro hacia adelante y hacia atr\u00e1s, con pausas de detenci\u00f3n entre cada cambio.</p>"},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#2-objetivos","title":"2) Objetivos","text":"<p>General: Controlar la direcci\u00f3n de rotaci\u00f3n de un motor DC mediante el uso de un puente H controlado por el ESP32.  </p> <p>Espec\u00edficos: - OE1: Configurar los pines del ESP32 como salidas digitales. - OE2: Programar el control de sentido (adelante/atr\u00e1s). - OE3: Implementar pausas de parada entre los cambios de direcci\u00f3n.  </p>"},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<p>Incluye: - Control de direcci\u00f3n de un solo motor DC. - Implementaci\u00f3n con puente H L298N. - Alimentaci\u00f3n de 6 V para el motor.  </p> <p>No incluye: - Control de velocidad (PWM). - Sensores o control autom\u00e1tico. - Comunicaci\u00f3n con otros dispositivos.  </p>"},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#4-requisitos","title":"4) Requisitos","text":"<p>Software: - Arduino IDE 2.x o superior. - Librer\u00eda ESP32 (instalada desde el Gestor de Placas).  </p> <p>Hardware: - ESP32 DevKit. - Puente H L298N. - Motor DC de 6 V. - Fuente externa de 6 V. - Cables Dupont / protoboard.  </p> <p>Conocimientos previos: - Programaci\u00f3n b\u00e1sica en Arduino. - Manejo de se\u00f1ales digitales. - Conceptos de puente H.  </p>"},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#5-codigo","title":"5) C\u00f3digo","text":"<pre><code>#define in1 27\n#define in2 14\n\nvoid setup() {\n  /* Declarar pines como salida */\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n}\n\nvoid loop() {\n  /* ADELANTE */\n  digitalWrite(in1, LOW);\n  digitalWrite(in2, HIGH);\n  delay(1000);\n\n  /* ALTO */\n  digitalWrite(in1, LOW);\n  digitalWrite(in2, LOW);\n  delay(1000);\n\n  /* ATR\u00c1S */\n  digitalWrite(in1, HIGH);\n  digitalWrite(in2, LOW);\n  delay(1000);\n\n  /* ALTO */\n  digitalWrite(in1, LOW);\n  digitalWrite(in2, LOW);\n  delay(1000);\n}\n</code></pre>"},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#videos","title":"videos","text":"Tu navegador no soporta la reproducci\u00f3n de video."},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#practica-2-control-de-potencia-de-un-motor-dc-con-esp32-y-pwm","title":"Pr\u00e1ctica 2 \u2013 Control de potencia de un motor DC con ESP32 y PWM","text":""},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#1-resumen_1","title":"1) Resumen","text":"<p>Nombre del proyecto: Control de Potencia de Motor DC Equipo / Autor(es): Jos\u00e9 Ismael Guerrero Rom\u00e1n y Gerardo Esquivel De Luna Curso / Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica Fecha: 10/oct/25 Descripci\u00f3n breve: Se utiliz\u00f3 un ESP32 y un puente H (L298N) alimentado a 6 V para controlar la velocidad de un motor DC mediante modulaci\u00f3n por ancho de pulso (PWM), variando progresivamente su potencia desde el valor m\u00e1ximo hasta el m\u00ednimo.</p>"},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#2-objetivos_1","title":"2) Objetivos","text":"<p>General: Regular la velocidad de un motor DC utilizando se\u00f1ales PWM generadas por el ESP32.  </p> <p>Espec\u00edficos: - OE1: Configurar un canal PWM en el ESP32 con la frecuencia y resoluci\u00f3n adecuadas. - OE2: Implementar un programa que incremente y luego disminuya la velocidad del motor. - OE3: Observar y analizar la respuesta del motor ante los diferentes niveles de potencia.  </p>"},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#3-alcance-y-exclusiones_1","title":"3) Alcance y Exclusiones","text":"<p>Incluye: - Control de velocidad mediante modulaci\u00f3n PWM. - Configuraci\u00f3n y uso del puente H con alimentaci\u00f3n de 6 V. - Conexi\u00f3n entre el ESP32, el puente H y el motor DC.  </p> <p>No incluye: - Cambio de direcci\u00f3n del motor. - Lectura de sensores de velocidad o retroalimentaci\u00f3n. - Control remoto o comunicaci\u00f3n inal\u00e1mbrica.  </p>"},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#4-requisitos_1","title":"4) Requisitos","text":"<p>Software: - Arduino IDE 2.x o superior. - Librer\u00eda del ESP32 instalada desde el Gestor de Placas.  </p> <p>Hardware: - ESP32 DevKit. - Puente H L298N. - Motor DC de 6 V. - Fuente externa de 6 V. - Protoboard y cables Dupont.  </p> <p>Conocimientos previos: - Programaci\u00f3n b\u00e1sica en Arduino y ESP32. - Conceptos de modulaci\u00f3n por ancho de pulso (PWM). - Electr\u00f3nica b\u00e1sica y conexiones con puente H.  </p>"},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#5-codigo_1","title":"5) C\u00f3digo","text":"<pre><code>#define IN1 27\n#define IN2 14\n#define PWM_PIN 12\n\n// Configuraci\u00f3n del canal PWM\n#define PWM_CHANNEL 0\n#define PWM_FREQ 1000   // Frecuencia de 1 kHz\n#define PWM_RES 8       // Resoluci\u00f3n de 8 bits (valores 0 a 255)\n\nvoid setup() {\n  /* Configurar pines de salida */\n  pinMode(IN1, OUTPUT);\n  pinMode(IN2, OUTPUT);\n\n  /* Configurar canal PWM */\n  ledcSetup(PWM_CHANNEL, PWM_FREQ, PWM_RES);\n\n  /* Asociar el pin f\u00edsico al canal PWM */\n  ledcAttachPin(PWM_PIN, PWM_CHANNEL);\n}\n\nvoid loop() {\n  /* GIRO HACIA ADELANTE */\n  digitalWrite(IN1, LOW);\n  digitalWrite(IN2, HIGH);\n\n  /* Aumentar gradualmente la velocidad */\n  for (int i = 0; i &lt;= 255; i++) {\n    ledcWrite(PWM_CHANNEL, i);\n    delay(10);  // Aumento progresivo\n  }\n\n  /* Mantener velocidad m\u00e1xima */\n  delay(1000);\n\n  /* Disminuir gradualmente la velocidad */\n  for (int i = 255; i &gt;= 0; i--) {\n    ledcWrite(PWM_CHANNEL, i);\n    delay(10);  // Disminuci\u00f3n progresiva\n  }\n\n  /* Detener el motor */\n  digitalWrite(IN1, LOW);\n  digitalWrite(IN2, LOW);\n  delay(1000);\n}\n</code></pre>"},{"location":"Control%20de%20motores%20DC%20con%20ESP32%20y%20Puente%20H/#videos_1","title":"videos","text":"Tu navegador no soporta la reproducci\u00f3n de video."},{"location":"Control%20de%20un%20Servo%20con%20un%20ESP32/","title":"Actividad 7: Control Angular de Servomotor con ESP32","text":""},{"location":"Control%20de%20un%20Servo%20con%20un%20ESP32/#finalidad-del-laboratorio","title":"Finalidad del Laboratorio","text":"<p>El prop\u00f3sito fundamental de esta pr\u00e1ctica fue analizar y aplicar los principios operativos de un servomotor utilizando las capacidades de generaci\u00f3n de se\u00f1al PWM de la placa ESP32. El objetivo espec\u00edfico se centr\u00f3 en la secuenciaci\u00f3n precisa del eje del servo a tres \u00e1ngulos clave predefinidos: 0\u00b0, 90\u00b0 y 180\u00b0, asegurando un movimiento controlado y repetitivo.</p>"},{"location":"Control%20de%20un%20Servo%20con%20un%20ESP32/#fundamentos-teoricos","title":"Fundamentos Te\u00f3ricos","text":""},{"location":"Control%20de%20un%20Servo%20con%20un%20ESP32/#introduccion-al-servocontrol","title":"Introducci\u00f3n al Servocontrol","text":"<p>Los servomotores son dispositivos actuadores fundamentales en la rob\u00f3tica, conocidos por su capacidad para lograr un control angular exacto dentro de un rango limitado (com\u00fanmente 180\u00b0). El control de su posici\u00f3n se realiza a trav\u00e9s de la Modulaci\u00f3n por Ancho de Pulso (PWM), donde el ancho del pulso el\u00e9ctrico (ciclo de trabajo) que reciben es directamente proporcional al \u00e1ngulo de giro deseado.</p>"},{"location":"Control%20de%20un%20Servo%20con%20un%20ESP32/#implementacion-con-esp32","title":"Implementaci\u00f3n con ESP32","text":"<p>El microcontrolador ESP32 es id\u00f3neo para esta tarea, ya que su hardware permite una generaci\u00f3n de se\u00f1ales PWM altamente configurable en t\u00e9rminos de resoluci\u00f3n y frecuencia. Para la programaci\u00f3n, se emplean dos funciones esenciales del framework de Arduino: 1.  <code>ledcWrite()</code>: Se utiliza para enviar el valor del ciclo de trabajo PWM al pin de salida. 2.  <code>map()</code>: Es crucial para realizar la conversi\u00f3n matem\u00e1tica del rango de grados legible por el usuario (0 a 180) al rango espec\u00edfico de valores PWM que el servo interpreta.</p>"},{"location":"Control%20de%20un%20Servo%20con%20un%20ESP32/#procedimiento-experimental","title":"Procedimiento Experimental","text":""},{"location":"Control%20de%20un%20Servo%20con%20un%20ESP32/#materiales-requeridos","title":"Materiales Requeridos","text":"Componente Descripci\u00f3n Placa ESP32 (DOIT ESP32 DEVKIT V1) Microcontrolador principal. Servomotor Actuador de control angular. Protoboard Plataforma para el ensamblaje del circuito temporal. Cables Jumpers Conductores para interconexi\u00f3n. Fuente de Alimentaci\u00f3n Suministro de energ\u00eda independiente para el servo. Computadora y Cable USB Para el desarrollo y la carga del firmware en Arduino IDE."},{"location":"Control%20de%20un%20Servo%20con%20un%20ESP32/#metodologia-de-montaje-y-programacion","title":"Metodolog\u00eda de Montaje y Programaci\u00f3n","text":"<ol> <li>Montaje F\u00edsico: La ESP32 y el servo se ensamblaron en la protoboard. La l\u00ednea de se\u00f1al del servo se conect\u00f3 al GPIO 12 de la ESP32. Se aseguraron conexiones separadas de alimentaci\u00f3n (5V) y tierra (GND) para el servo. </li> <li>Desarrollo del C\u00f3digo: Se program\u00f3 la l\u00f3gica de control para establecer un ciclo secuencial de movimiento a 0\u00b0, 90\u00b0 y 180\u00b0. Se emple\u00f3 la funci\u00f3n <code>map()</code> para asegurar la correcta correspondencia entre los \u00e1ngulos y el ciclo de trabajo PWM.</li> <li>Verificaci\u00f3n: Se carg\u00f3 el programa a la ESP32 y se monitore\u00f3 el movimiento f\u00edsico del servo. Los retardos de 1000 ms se usaron para confirmar cada posici\u00f3n.</li> </ol>"},{"location":"Control%20de%20un%20Servo%20con%20un%20ESP32/#codigo-fuente-arduino-esp32","title":"C\u00f3digo Fuente (Arduino / ESP32)","text":"<p>Este c\u00f3digo implementa el control secuencial del servo motor, utilizando la librer\u00eda LEDC del ESP32 para generar la se\u00f1al PWM.</p> <pre><code>/**\n * @file Control_Servo_Libreria.ino\n * @brief Control secuencial de un servomotor (0\u00b0, 90\u00b0, 180\u00b0) usando la librer\u00eda Servo.h en ESP32.\n * * La librer\u00eda Servo.h simplifica el control al encargarse de la gesti\u00f3n interna del PWM.\n */\n\n// Incluir la librer\u00eda Servo espec\u00edfica para ESP32\n// NOTA: Para ESP32, a menudo se usa \"ESP32Servo.h\" o simplemente \"Servo.h\"\n// Si Servo.h no funciona, intente usar ESP32Servo.h\n#include &lt;Servo.h&gt; \n\n// --- Configuraci\u00f3n de Pines y Objetos ---\n\n#define SERVO_PIN 12 // Pin GPIO donde se conecta la se\u00f1al del servo (Pin de ejemplo)\n\n// Crea un objeto Servo para controlar el motor\nServo miServo; \n\n// --- Setup (Configuraci\u00f3n Inicial) ---\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(\"Inicializando Servomotor con Servo.h...\");\n\n  // Asocia el objeto Servo al pin de salida\n  // Este paso configura autom\u00e1ticamente el canal PWM necesario en el ESP32\n  miServo.attach(SERVO_PIN); \n\n  // Asegurar que el servo inicie en una posici\u00f3n conocida\n  miServo.write(0); \n  delay(1000);\n}\n\n// --- Loop Principal (Ejecuci\u00f3n Continua) ---\nvoid loop() {\n  // Mover a 0 grados\n  Serial.println(\"Movimiento a 0 grados\");\n  miServo.write(0); \n  delay(1500); // Usamos un retardo ligeramente mayor para notar el movimiento\n\n  // Mover a 90 grados\n  Serial.println(\"Movimiento a 90 grados\");\n  miServo.write(90); \n  delay(1500);\n\n  // Mover a 180 grados\n  Serial.println(\"Movimiento a 180 grados\");\n  miServo.write(180); \n  delay(1500);\n}\n</code></pre>"},{"location":"Control%20de%20un%20Servo%20con%20un%20ESP32/#analisis-de-resultados-detallado","title":"An\u00e1lisis de Resultados Detallado","text":"<p>Los resultados obtenidos durante la fase de pruebas confirmaron la viabilidad del m\u00e9todo de control implementado, demostrando lo siguiente:</p> <ul> <li>Respuesta del Actuador: El servomotor exhibi\u00f3 una respuesta angular precisa e inmediata a las se\u00f1ales de control generadas por el microcontrolador. El eje se posicion\u00f3 de manera exacta en cada uno de los puntos angulares preestablecidos (0\u00b0, 90\u00b0, 180\u00b0), verificando la integridad de la conexi\u00f3n f\u00edsica.</li> <li>Conversi\u00f3n Exitosa: La aplicaci\u00f3n de la funci\u00f3n <code>map()</code> result\u00f3 ser un elemento cr\u00edtico para la calibraci\u00f3n. Esta funci\u00f3n permiti\u00f3 la traducci\u00f3n efectiva y lineal del rango l\u00f3gico de grados (0-180) al rango espec\u00edfico del ciclo de trabajo PWM (205-410) requerido por el modelo particular del servomotor para su posicionamiento correcto.</li> <li>Monitoreo y Validaci\u00f3n: Los datos num\u00e9ricos del ciclo de trabajo PWM, comunicados a trav\u00e9s del monitor serial, coincidieron rigurosamente con los \u00e1ngulos observados en el movimiento f\u00edsico del servo. Esto valid\u00f3 la l\u00f3gica de programaci\u00f3n y la precisi\u00f3n del c\u00e1lculo matem\u00e1tico.</li> </ul>"},{"location":"Control%20de%20un%20Servo%20con%20un%20ESP32/#resumen-conclusivo","title":"Resumen Conclusivo","text":"<p>Esta actividad de laboratorio culmin\u00f3 exitosamente al consolidar la comprensi\u00f3n pr\u00e1ctica del mecanismo de control de actuadores angulares mediante la t\u00e9cnica PWM en la plataforma ESP32.</p> <p>Se cumpli\u00f3 el objetivo de lograr la secuenciaci\u00f3n controlada del servomotor a las posiciones 0\u00b0, 90\u00b0 y 180\u00b0, lo cual implic\u00f3 la validaci\u00f3n completa de la configuraci\u00f3n electr\u00f3nica (conexi\u00f3n y suministro de energ\u00eda) y la correcta implementaci\u00f3n del software. La pr\u00e1ctica reforz\u00f3 el entendimiento de la relaci\u00f3n cr\u00edtica y directa que existe entre la frecuencia del pulso, el ciclo de trabajo de la se\u00f1al PWM y el desplazamiento angular preciso que se obtiene en el servomotor.</p>"},{"location":"Control%20de%20un%20Servo%20con%20un%20ESP32/#video-de-la-practica","title":"video de la pr\u00e1ctica","text":"Tu navegador no soporta la reproducci\u00f3n de video."},{"location":"Creear%20una%20p%C3%A1gina%20web/","title":"Creear una p\u00e1gina web","text":""},{"location":"Creear%20una%20p%C3%A1gina%20web/#creacion-de-una-pagina-web-en-github-pages","title":"Creaci\u00f3n de una p\u00e1gina web en GitHub Pages","text":""},{"location":"Creear%20una%20p%C3%A1gina%20web/#1-resumen","title":"1) Resumen","text":"<p>Nombre del proyecto: Publicaci\u00f3n de p\u00e1gina web con GitHub Pages Equipo / Autor(es): Jos\u00e9 Ismael Guerrero Rom\u00e1n y Gerardo Esquivel De Luna Curso / Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica Fecha:   22/Ago/25 Descripci\u00f3n breve: En esta pr\u00e1ctica se cre\u00f3 y public\u00f3 una p\u00e1gina web est\u00e1tica utilizando GitHub Pages, una herramienta gratuita que permite alojar sitios web directamente desde un repositorio en GitHub. Se aprendi\u00f3 a crear el repositorio, subir archivos HTML y configurar la publicaci\u00f3n en l\u00ednea.</p>"},{"location":"Creear%20una%20p%C3%A1gina%20web/#2-objetivos","title":"2) Objetivos","text":"<p>General: Publicar una p\u00e1gina web b\u00e1sica en Internet utilizando GitHub Pages.  </p> <p>Espec\u00edficos: - OE1: Crear un repositorio en GitHub con los archivos del sitio web. - OE2: Configurar el repositorio para habilitar GitHub Pages. - OE3: Comprobar el funcionamiento del sitio publicado desde un navegador.  </p>"},{"location":"Creear%20una%20p%C3%A1gina%20web/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<p>Incluye: - Creaci\u00f3n de una p\u00e1gina web est\u00e1tica (HTML, CSS y JS). - Publicaci\u00f3n gratuita mediante GitHub Pages. - Visualizaci\u00f3n de la p\u00e1gina desde cualquier navegador.  </p> <p>No incluye: - Sitios con bases de datos o backend (solo contenido est\u00e1tico). - Integraci\u00f3n de dominios personalizados. - Edici\u00f3n avanzada con frameworks o gestores de contenido.  </p>"},{"location":"Creear%20una%20p%C3%A1gina%20web/#4-requisitos","title":"4) Requisitos","text":"<p>Software: - Navegador web actualizado. - Cuenta en GitHub. - (Opcional) Editor de c\u00f3digo como Visual Studio Code.  </p> <p>Hardware: - Computadora con conexi\u00f3n a Internet.  </p> <p>Conocimientos previos: - Conceptos b\u00e1sicos de HTML y estructura de carpetas. - Manejo b\u00e1sico de GitHub (crear repositorios y subir archivos).  </p>"},{"location":"Creear%20una%20p%C3%A1gina%20web/#5-procedimiento-paso-a-paso","title":"5) Procedimiento paso a paso","text":""},{"location":"Creear%20una%20p%C3%A1gina%20web/#paso-1-crear-una-cuenta-en-github","title":"Paso 1: Crear una cuenta en GitHub","text":"<ol> <li>Ingresar a https://github.com.  </li> <li>Crear una cuenta nueva o iniciar sesi\u00f3n si ya se tiene una.  </li> </ol>"},{"location":"Creear%20una%20p%C3%A1gina%20web/#paso-2-crear-un-nuevo-repositorio","title":"Paso 2: Crear un nuevo repositorio","text":"<ol> <li>Desde el perfil, hacer clic en el bot\u00f3n \u201cNew repository\u201d.  </li> <li>Asignar un nombre al repositorio, por ejemplo:  </li> <li>Marcar la opci\u00f3n \u201cPublic\u201d y, si se desea, a\u00f1adir un archivo README.md.  </li> <li>Presionar \u201cCreate repository\u201d.  </li> </ol>"},{"location":"Creear%20una%20p%C3%A1gina%20web/#paso-3-subir-los-archivos-de-la-pagina","title":"Paso 3: Subir los archivos de la p\u00e1gina","text":"<ol> <li>Dentro del nuevo repositorio, hacer clic en \u201cAdd file\u201d \u2192 \u201cUpload files\u201d.  </li> <li>Seleccionar los archivos del sitio web, por ejemplo:</li> <li><code>index.html</code> </li> <li><code>style.css</code> </li> <li><code>script.js</code></li> <li>Hacer clic en \u201cCommit changes\u201d para guardar los archivos.  </li> </ol>"},{"location":"Creear%20una%20p%C3%A1gina%20web/#paso-4-habilitar-github-pages","title":"Paso 4: Habilitar GitHub Pages","text":"<ol> <li>Entrar a la pesta\u00f1a \u201cSettings\u201d del repositorio.  </li> <li>Desplazarse hacia abajo hasta la secci\u00f3n \u201cPages\u201d.  </li> <li>En \u201cSource\u201d, seleccionar la rama <code>main</code> y la carpeta <code>/ (root)</code>.  </li> <li>Presionar \u201cSave\u201d.  </li> </ol>"},{"location":"Creear%20una%20p%C3%A1gina%20web/#paso-5-obtener-la-url-del-sitio","title":"Paso 5: Obtener la URL del sitio","text":"<ol> <li>GitHub generar\u00e1 un enlace con el formato:</li> <li>Esperar unos minutos a que se procese la publicaci\u00f3n.  </li> <li>Abrir el enlace en un navegador para visualizar la p\u00e1gina en l\u00ednea.  </li> </ol>"},{"location":"Creear%20una%20p%C3%A1gina%20web/#6-codigo-de-ejemplo-indexhtml","title":"6) C\u00f3digo de ejemplo (index.html)","text":"<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"es\"&gt;\n&lt;head&gt;\n&lt;meta charset=\"UTF-8\"&gt;\n&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n&lt;title&gt;Mi Primera P\u00e1gina con GitHub Pages&lt;/title&gt;\n&lt;style&gt;\n body {\n   font-family: Arial, sans-serif;\n   background-color: #f0f2f5;\n   text-align: center;\n   margin-top: 100px;\n }\n h1 {\n   color: #005bbb;\n }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;\u00a1Hola Mundo!&lt;/h1&gt;\n&lt;p&gt;Esta es mi primera p\u00e1gina web publicada en GitHub Pages.&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"Equipo%20de%20trabajo/","title":"Equipo de Trabajo.","text":"<ul> <li>Con\u00f3cenos, equipo de trabajo en Introducci\u00f3n a la Mecatr\u00f3nica.</li> </ul>"},{"location":"Equipo%20de%20trabajo/#jose-ismael-guerrero-roman","title":"Jos\u00e9 Ismael Guerrero Rom\u00e1n.","text":"<ul> <li>Carrera: Ing Mecatr\u00f3nica</li> <li>Cosas que me gustan hacer: Me gusta jugar videojuegos, escuchar m\u00fasica y estar informado de la tecnolog\u00eda y de los avances que logramos con ella y finalmente, otro de mis gustos es la f\u00f3rmula 1.</li> <li>Cosas de las que estoy orgulloso: Estoy Orgulloso, de como he crecido como persona a lo largo del tiempo y de como a pesar de mis errores y aciertos en la vida he podido, levantarme y aprender algo aunque sea m\u00ednimo, de las personas que me rodean y como en ocasiones he podido llegar a influir positivamente en ellos, tanto como amigos y familia, de igual manera estoy orgulloso, de haber podido mantener una buena trayectoria acad\u00e9mica a lo largo de mis estudios y de poder seguir estudiando en esta etapa de mi vida.</li> <li>Edad: 18</li> <li>Cumplea\u00f1os: 23 Julio</li> <li>Contacto: 203563@iberopuebla.mx</li> </ul>"},{"location":"Equipo%20de%20trabajo/#gerardo-esquivel-de-luna","title":"Gerardo Esquivel De Luna","text":"<ul> <li>Carrera: Ing Mecatr\u00f3nica</li> <li>Cosas que me gustan hacer: videojuegos, monta\u00f1ismo, ciclismo.</li> <li>Cosas de las que estoy orgulloso: De ser una persona perseverante, que no se rinde f\u00e1cilmente, por haber superado momentos dif\u00edciles y seguir avanzando y por ser alguien que ayuda a los dem\u00e1s cuando lo necesitan.</li> <li>Edad: 18</li> <li>Cumplea\u00f1os: 18 Julio</li> <li>Contacto: 204655@iberopuebla.mx</li> </ul>"},{"location":"LED%20intermitente%20con%20temporizador%20555/","title":"LED intermitente con temporizador 555 en modo astable","text":""},{"location":"LED%20intermitente%20con%20temporizador%20555/#1-resumen","title":"1) Resumen","text":"<p>Nombre del proyecto: LED intermitente con temporizador 555 en modo astable Equipo / Autor(es): Jos\u00e9 Ismael Guerrero Rom\u00e1n y Gerardo Esquivel De Luna Curso / Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica Fecha: 06/09/25 Descripci\u00f3n breve: Se dise\u00f1\u00f3 e implement\u00f3 un circuito astable con el temporizador 555 para generar el parpadeo de un LED en un intervalo regulable de 1 a 5 segundos, aplicando conceptos de electr\u00f3nica anal\u00f3gica.  </p>"},{"location":"LED%20intermitente%20con%20temporizador%20555/#2-objetivos","title":"2) Objetivos","text":"<p>General: Implementar un circuito con temporizador 555 en modo astable para controlar el parpadeo de un LED con un intervalo ajustable de tiempo.  </p> <p>Espec\u00edficos: - OE1: Calcular y seleccionar resistencias y capacitores adecuados para obtener un rango de parpadeo de 1 a 5 segundos. - OE2: Ensamblar el circuito en protoboard verificando las conexiones correctas. - OE3: Comprobar experimentalmente el funcionamiento del LED intermitente y documentar los resultados.  </p>"},{"location":"LED%20intermitente%20con%20temporizador%20555/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<p>Incluye: - Dise\u00f1o del circuito astable con 555. - C\u00e1lculo de tiempos de encendido/apagado del LED. - Montaje en protoboard y comprobaci\u00f3n de funcionamiento. - Evidencia en fotos y videos del resultado.  </p> <p>No incluye: - Dise\u00f1o de PCB definitivo. - Control de m\u00e1s de un LED o integraci\u00f3n con microcontroladores. - Alimentaciones distintas a 5 V o 9 V.  </p>"},{"location":"LED%20intermitente%20con%20temporizador%20555/#4-requisitos","title":"4) Requisitos","text":"<p>Software: - No se requiri\u00f3 software espec\u00edfico, solo calculadora electr\u00f3nica b\u00e1sica para el dimensionamiento de componentes.  </p> <p>Hardware: - CI NE555 (temporizador). - Resistencia R1 = 1 k\u03a9. - Resistencia R2 = 6.8 k\u03a9 + potenci\u00f3metro de 30 k\u03a9. - Capacitor electrol\u00edtico C = 100 \u00b5F. - Resistencia limitadora para LED (330 \u03a9 a 820 \u03a9 seg\u00fan Vcc). - LED rojo. - Protoboard y cables de conexi\u00f3n. - Fuente de poder de 5 V o 9 V.  </p> <p>Conocimientos previos: - Electr\u00f3nica b\u00e1sica: resistencias, capacitores, LED, temporizador 555. - C\u00e1lculo de tiempos en modo astable. - Manejo de protoboard y mult\u00edmetro.  </p>    Tu navegador no soporta la reproducci\u00f3n de video.  <p></p>"},{"location":"Presentacion/","title":"Acerca de mi","text":"<p>Mi nombre es Jos\u00e9 Ismael Guerrero Rom\u00e1n, tengo 18 a\u00f1os, estudio actualmente la carrera de Ing Mecatr\u00f3nica, eleg\u00ed esta carrera ya que desde peque\u00f1o, siempre me sent\u00ed atra\u00eddo por lo impresionante que puede ser un mecanismo cuando comprendes como funciona y descubres todos los dem\u00e1s usos que eso puede tener y de cierta forma la creatividad que debes tener para poder dar una soluci\u00f3n a un problema, desde peque\u00f1o comenc\u00e9 a aprender sobre el funcionamiento de algunos robots de juguete y durante la preparatoria ampec\u00e9 a aprender a programar en python, lo cual me pareci\u00f3 a\u00fan m\u00e1s fascinante, el como a partir de codigos e instrucciones, puedes lograr que la computadora endienta y ejecute muchas acciones peque\u00f1as para poder lograr algo enorme.</p>"},{"location":"Presentacion/#mis-gustos","title":"Mis gustos","text":"<p>Algunos de mis gustos o hobbies son: La musica, suelo escuchar de todo pero ultimamente, me he enfocado en oir m\u00e1s un poco de tecno y house tranquilo,me gusta ver la f\u00f3rmula uno y la ingenieria y el trabajo o proceso que existe detras de poder crear un auto casi tan perfecto que pueda tomar una curva a mas de 250 km/h y finalmente otro de mis gustos es la tecnolog\u00eda, estar al pendiente de los nuevos avances que han tenido y como al juntar esa tecnolog\u00eda con cosas cotidianas de nuestra vida, podemos hacerla m\u00e1s facil y al mismo tiempo podemos alcanzar una mayor eficiencia en nuestras vidas.</p>"},{"location":"Presentacion/#mi-yo-futuro","title":"Mi yo futuro","text":"<p>En diez a\u00f1os me gustar\u00eda verme como alguien que ya ha alcanzado el \u00e9xito academico, quien ha aprendido de personas y de los propios errores cometidos en esta vida y que ha sabido orientar y enfocar todo lo que sabe en busqueda de poder aportar algo nuevo y bueno a la sociedad, en mi caso mediante mi carrera, me gustaria poder trabajar en sistemas de inteligencia que busque ayudar a la poblaci\u00f3n, me veo en un trabajo estable y que disfruto hacer, trabajando en algo que me apasione realmente.</p>"},{"location":"Proyecto%201%20/","title":"Proyecto Final: Carro Robot de F\u00fatbol Controlado por PS4 (ESP32)","text":""},{"location":"Proyecto%201%20/#objetivo-del-proyecto","title":"Objetivo del Proyecto","text":"<p>El proyecto consisti\u00f3 en el dise\u00f1o y construcci\u00f3n de un carro robot teledirigido utilizando el microcontrolador ESP32 y un control PS4 (v\u00eda Bluetooth). El objetivo principal era crear una plataforma m\u00f3vil con alta maniobrabilidad para participar y competir exitosamente en un torneo de f\u00fatbol de robots, moviendo una pelota y marcando goles.</p>"},{"location":"Proyecto%201%20/#arquitectura-y-tecnologias","title":"Arquitectura y Tecnolog\u00edas","text":"<p>La implementaci\u00f3n se centr\u00f3 en la integraci\u00f3n de tres \u00e1reas principales:</p>"},{"location":"Proyecto%201%20/#marco-teorico","title":"Marco Te\u00f3rico","text":"<ul> <li>Microcontrolador: Se seleccion\u00f3 el ESP32 por su capacidad de doble n\u00facleo y, fundamentalmente, por su conectividad Bluetooth para recibir comandos en tiempo real desde el control de PlayStation.</li> <li>Driver de Motor: Se utiliz\u00f3 un Puente H (L298N o similar) para gestionar la alta corriente requerida por los motores DC, ya que el ESP32 no puede alimentarlos directamente.</li> <li>Movimiento: Se implement\u00f3 Tracci\u00f3n Diferencial mediante el env\u00edo de se\u00f1ales PWM (Modulaci\u00f3n por Ancho de Pulso) a cada motor, permitiendo movimientos precisos (avance, retroceso y giros).</li> </ul>"},{"location":"Proyecto%201%20/#materiales-clave","title":"Materiales Clave","text":"Componente Funci\u00f3n Principal ESP32 DevKit V1 Cerebro del sistema, gestor de Bluetooth. Puente H Driver de potencia para los motores. Control PS4 Interfaz de usuario para comandos inal\u00e1mbricos. Pilas 3.7V / 2600 mAh Fuente de alimentaci\u00f3n. Motores DC Actuadores de tracci\u00f3n. MDF / Impresi\u00f3n 3D Construcci\u00f3n del chasis, carcasas y pala."},{"location":"Proyecto%201%20/#procedimiento-general","title":"Procedimiento General","text":"<p>El proyecto se ejecut\u00f3 mediante la colaboraci\u00f3n de equipos especializados:</p> <ol> <li>Electr\u00f3nica: Dise\u00f1o del diagrama del circuito, conexi\u00f3n del driver de motor, fusibles, bater\u00edas y cableado general.</li> <li>Programaci\u00f3n: Desarrollo del firmware para la conexi\u00f3n Bluetooth y la l\u00f3gica de control de motores, traduciendo los comandos del joystick a se\u00f1ales de movimiento.</li> <li>Mec\u00e1nica: Dise\u00f1o y ensamblaje del chasis de cuatro ruedas y la pala frontal para la interacci\u00f3n con la pelota.</li> </ol>"},{"location":"Proyecto%201%20/#codigo-de-programacion-arduino-para-esp32","title":"C\u00f3digo de Programaci\u00f3n (Arduino para ESP32)","text":"<p>Este firmware gestiona la conexi\u00f3n con el control PS4 y utiliza la l\u00f3gica de tracci\u00f3n diferencial y ajuste de velocidad (con el gatillo R2) para el control del carro.</p> <pre><code>/**\n * @file Robot_Futbol_PS4_ESP32.ino\n * @brief C\u00f3digo para controlar un carro robot de f\u00fatbol usando un ESP32 y un control PS4.\n * Incluye funciones para avance, retroceso, giros y tracci\u00f3n diferencial mediante Joysticks.\n */\n\n// Bibliotecas necesarias:\n#include &lt;Arduino.h&gt;\n#include &lt;PS4Controller.h&gt; \n\n// --- Configuraci\u00f3n de Pines y Variables ---\nint enA = 25; int enB = 14; // Pines de Enable (PWM)\nint IN1 = 26; int IN2 = 27; int IN3 = 32; int IN4 = 33; // Pines de Direcci\u00f3n\n#define R 0 // Canal LEDC para Motor Derecho\n#define L 1 // Canal LEDC para Motor Izquierdo\nint Speed = 210; // Velocidad base inicial\nint threshold = 10; // Umbral de sensibilidad para Joysticks\n\n// --- Declaraci\u00f3n de Funciones de Movimiento ---\nvoid forward(); void backward(); void left(); void right(); void stop();\nvoid setMotor(int leftMotor, int rightMotor);\n\n// --- Setup (Configuraci\u00f3n Inicial) ---\nvoid setup() {\n  Serial.begin(115200);\n  // **IMPORTANTE**: Reemplace la MAC Address con la de su control PS4.\n  PS4.begin(\"98:3b:8f:fc:0c:82\"); \n  Serial.println(\"Esperando control PS4...\");\n  ledcAttachChannel(enA, 5000, 8, R);\n  ledcAttachChannel(enB, 5000, 8, L);\n  pinMode(IN1, OUTPUT); pinMode(IN2, OUTPUT);\n  pinMode(IN3, OUTPUT); pinMode(IN4, OUTPUT);\n  stop();\n}\n\n// --- Loop Principal (Ejecuci\u00f3n Continua) ---\nvoid loop() {\n  if (PS4.isConnected()) {\n    // 1. Ajuste de Velocidad con R2\n    Speed = map(PS4.R2Value(), 0, 255, 210, 255);\n\n    // 2. Control con D-Pad (Movimientos b\u00e1sicos)\n    if (PS4.Up()) forward();\n    else if (PS4.Down()) backward();\n    else if (PS4.Left()) left();\n    else if (PS4.Right()) right();\n\n    // 3. Control con Joysticks (Tracci\u00f3n Diferencial)\n    else {\n      int lx = PS4.LStickX(); int ly = PS4.LStickY();\n      int rx = PS4.RStickX(); int ry = PS4.RStickY();\n\n      if (abs(ly) &gt; threshold || abs(lx) &gt; threshold || abs(ry) &gt; threshold || abs(rx) &gt; threshold) {\n        int forwardSpeed = map(-ly, -128, 127, -Speed, Speed);\n        int turnSpeed    = map(lx, -128, 127, -Speed, Speed);\n        int diagX = map(rx, -128, 127, -Speed, Speed);\n        int diagY = map(-ry, -128, 127, -Speed, Speed);\n\n        // C\u00e1lculo de Tracci\u00f3n Diferencial\n        int leftMotor = constrain(forwardSpeed + turnSpeed + diagY + diagX, -255, 255);\n        int rightMotor = constrain(forwardSpeed - turnSpeed + diagY - diagX, -255, 255);\n\n        setMotor(leftMotor, rightMotor);\n      } else {\n        stop();\n      }\n    }\n    delay(50); \n  }\n}\n\n// --- Implementaci\u00f3n de Funciones de Movimiento ---\n\nvoid forward() {\n  ledcWrite(R, Speed); ledcWrite(L, Speed);\n  digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);\n  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);\n}\n\nvoid backward() {\n  ledcWrite(R, Speed); ledcWrite(L, Speed);\n  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);\n  digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);\n}\n\nvoid left() {\n  ledcWrite(R, Speed); ledcWrite(L, Speed);\n  digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);\n  digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);\n}\n\nvoid right() {\n  ledcWrite(R, Speed); ledcWrite(L, Speed);\n  digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);\n  digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);\n}\n\nvoid stop() {\n  ledcWrite(R, 0); ledcWrite(L, 0);\n  digitalWrite(IN1, LOW); digitalWrite(IN2, LOW);\n  digitalWrite(IN3, LOW); digitalWrite(IN4, LOW);\n}\n\nvoid setMotor(int leftMotor, int rightMotor) {\n  // Motor Izquierdo\n  if (leftMotor &gt;= 0) {\n    digitalWrite(IN1, LOW); digitalWrite(IN2, HIGH);\n    ledcWrite(L, leftMotor);\n  } else {\n    digitalWrite(IN1, HIGH); digitalWrite(IN2, LOW);\n    ledcWrite(L, -leftMotor);\n  }\n\n  // Motor Derecho\n  if (rightMotor &gt;= 0) {\n    digitalWrite(IN3, HIGH); digitalWrite(IN4, LOW);\n    ledcWrite(R, rightMotor);\n  } else {\n    digitalWrite(IN3, LOW); digitalWrite(IN4, HIGH);\n    ledcWrite(R, -rightMotor);\n  }\n}\n</code></pre>"},{"location":"Proyecto%201%20/#desempeno-y-resultados-de-la-competencia","title":"Desempe\u00f1o y Resultados de la Competencia","text":"<p>Los resultados validaron la robustez del dise\u00f1o electr\u00f3nico y la eficiencia de la programaci\u00f3n:</p> <ul> <li>Movilidad Verificada: El veh\u00edculo demostr\u00f3 una movilidad impecable y controlada, respondiendo de manera inmediata a los comandos del mando PS4.</li> <li>Ajuste Fino: Las pruebas fueron cruciales para calibrar la velocidad y la respuesta de los motores y optimizar la pala frontal.</li> <li>Victoria Confirmada: El robot interactu\u00f3 eficazmente con el bal\u00f3n y anot\u00f3 consistentemente, lo que se tradujo en una victoria en la competencia de f\u00fatbol de robots.</li> <li>Sinergia de Equipos: La integraci\u00f3n de las \u00e1reas de electr\u00f3nica, programaci\u00f3n y mec\u00e1nica se realiz\u00f3 de manera fluida, culminando en un carro funcional y de alto rendimiento.</li> </ul>"},{"location":"Proyecto%201%20/#conclusiones-finales","title":"Conclusiones Finales","text":"<p>El proyecto fue un \u00e9xito integral que demostr\u00f3 la aplicaci\u00f3n pr\u00e1ctica de la ingenier\u00eda de sistemas:</p> <ul> <li>Integraci\u00f3n Exitosa: Se logr\u00f3 una sincronizaci\u00f3n robusta entre el hardware y el software, estableciendo un sistema de control en tiempo real eficiente.</li> <li>Desarrollo de Habilidades: El proceso reforz\u00f3 capacidades esenciales como la planificaci\u00f3n, el trabajo en equipo y la resoluci\u00f3n de problemas t\u00e9cnicos.</li> <li>Objetivo Cumplido: La funcionalidad del robot para competir y jugar f\u00fatbol fue probada con \u00e9xito, cumpliendo plenamente el objetivo inicial del proyecto.</li> </ul> <p>Reflexi\u00f3n: Este proyecto subraya el valor de la colaboraci\u00f3n multidisciplinaria (combinando creatividad, ingenier\u00eda y c\u00f3digo) como el pilar fundamental para crear un producto tangible, educativo y de alto rendimiento.</p>"},{"location":"Proyecto%201%20/#fotos-y-videos","title":"Fotos y Videos","text":"Tu navegador no soporta la reproducci\u00f3n de video."},{"location":"Proyecto%20Final%20del%20semestre/","title":"Proyecto Final de Semestre: Plataforma de Balance de Pelota (Ball Balancing Platform)","text":""},{"location":"Proyecto%20Final%20del%20semestre/#introduccion","title":"Introducci\u00f3n","text":"<p>Este proyecto se centr\u00f3 en el dise\u00f1o e implementaci\u00f3n de un sistema de control de posici\u00f3n en tiempo real de dos grados de libertad (2 DOF). El objetivo fue construir una plataforma din\u00e1mica capaz de mantener una pelota centrada sobre su superficie, contrarrestando activamente la fuerza de gravedad mediante la inclinaci\u00f3n controlada de la base.</p> <p>El sistema emplea una arquitectura avanzada que combina Visi\u00f3n por Computadora (Python/OpenCV) para la detecci\u00f3n de errores y el microcontrolador ESP32 para la ejecuci\u00f3n precisa del movimiento a trav\u00e9s de servomotores.</p>"},{"location":"Proyecto%20Final%20del%20semestre/#marco-teorico-y-arquitectura-del-sistema","title":"Marco Te\u00f3rico y Arquitectura del Sistema","text":"<p>El proyecto se sustenta en tres pilares tecnol\u00f3gicos que trabajan en un lazo de control cerrado (closed-loop):</p>"},{"location":"Proyecto%20Final%20del%20semestre/#1-vision-por-computadora-y-deteccion-de-posicion","title":"1. Visi\u00f3n por Computadora y Detecci\u00f3n de Posici\u00f3n","text":"<p>Se utiliz\u00f3 Python junto con OpenCV para capturar el stream de video, actuando como el sensor de posici\u00f3n del sistema.</p> <ul> <li>Procesamiento: El c\u00f3digo identifica la Pelota (Amarilla) y la Plataforma (Verde) usando segmentaci\u00f3n HSV y morfolog\u00eda.</li> <li>Error de Posici\u00f3n: El Error se calcula como la diferencia en p\u00edxeles entre la posici\u00f3n actual de la pelota y el centro de la plataforma detectada. Este error es la entrada principal para el algoritmo de control.</li> <li>Detecci\u00f3n Dual: Se implement\u00f3 una detecci\u00f3n de dos objetos simult\u00e1nea para calcular el error con respecto al centro de la plataforma, haciendo el sistema m\u00e1s robusto.</li> </ul>"},{"location":"Proyecto%20Final%20del%20semestre/#2-protocolo-de-comunicacion-serial-inalambrica","title":"2. Protocolo de Comunicaci\u00f3n Serial Inal\u00e1mbrica","text":"<p>Para la transmisi\u00f3n de datos, se emple\u00f3 la comunicaci\u00f3n Bluetooth Serial entre la PC (Python) y el hardware (ESP32).</p> <ul> <li>Funci\u00f3n: Garantiza una conexi\u00f3n inal\u00e1mbrica de baja latencia necesaria para tareas de control en tiempo real.</li> <li>Mensaje: El c\u00f3digo Python calcula los \u00e1ngulos de correcci\u00f3n y los env\u00eda como una cadena de texto en el formato <code>X,Y\\n</code> al ESP32.</li> </ul>"},{"location":"Proyecto%20Final%20del%20semestre/#3-control-de-inclinacion-y-algoritmo-pid","title":"3. Control de Inclinaci\u00f3n y Algoritmo PID","text":"<p>Los servomotores fueron elegidos como actuadores por su capacidad de posicionamiento angular preciso.</p> <ul> <li>Actuaci\u00f3n: El ESP32 recibe los valores angulares y mueve los dos servomotores que controlan los ejes de inclinaci\u00f3n X y Y de la plataforma.</li> <li>Algoritmo PID (Proporcional-Integral-Derivativo): La l\u00f3gica de Python utiliza el PID para convertir el error de posici\u00f3n (p\u00edxeles) en una magnitud de correcci\u00f3n (\u00e1ngulo). El objetivo es que, si la pelota se mueve en la direcci\u00f3n X positiva, la plataforma se incline en la direcci\u00f3n X negativa para corregir el movimiento.</li> </ul>"},{"location":"Proyecto%20Final%20del%20semestre/#procedimiento-e-implementacion","title":"Procedimiento e Implementaci\u00f3n","text":""},{"location":"Proyecto%20Final%20del%20semestre/#materiales-clave","title":"Materiales Clave","text":"Componente Funci\u00f3n Microcontrolador ESP32 DevKit V (Con Bluetooth Integrado) Actuadores 2 Servomotores (Ejes X y Y) Sensor C\u00e1mara Webcam USB (Fuente de visi\u00f3n) Control Python (OpenCV, NumPy, Serial) Firmware Arduino IDE (ESP32Servo, BluetoothSerial)"},{"location":"Proyecto%20Final%20del%20semestre/#logica-de-control-en-python","title":"L\u00f3gica de Control en Python","text":"<p>El script implementa una l\u00f3gica avanzada para la estabilidad:</p> Componente Kp/Ki/Kd Ajustados Funci\u00f3n en el Control PID Kp=0.15, Ki=0.001, Kd=0.20 Convierte el Error (p\u00edxeles) en un output de correcci\u00f3n continuo. Suavizado (<code>smoothing=0.3</code>) Media M\u00f3vil Exponencial. Filtra el ruido de la c\u00e1mara y evita movimientos bruscos en el servo. Zona Muerta (<code>DEAD_ZONE=15</code>) \u00b115 p\u00edxeles. Define una zona central de tolerancia donde no se aplica correcci\u00f3n para prevenir oscilaciones. Limitaci\u00f3n (<code>constrain</code>) Rango 0\u00b0 a 110\u00b0. Asegura que el \u00e1ngulo del servo permanezca en un rango f\u00edsico seguro."},{"location":"Proyecto%20Final%20del%20semestre/#codigo-python-fragmento-de-control","title":"C\u00f3digo Python (Fragmento de Control)","text":"<pre><code>#PruebaBUENA - Modificado: Pelota AMARILLA y Plataforma VERDE\n\nimport cv2\nimport time\nimport numpy as np\nimport serial\nimport serial.tools.list_ports\n\n# ------------------- Configuraci\u00f3n Serial Bluetooth -------------------\nesp32_port = 'COM14'\nbaud_rate = 115200\n\nprint(\"=\" * 50)\nprint(\"Intentando conectar con ESP32...\")\nprint(f\"Puerto: {esp32_port} | Baudios: {baud_rate}\")\n\ndef listar_puertos():\n    puertos = serial.tools.list_ports.comports()\n    print(\"\\n Puertos COM disponibles:\")\n    if len(puertos) == 0:\n        print(\"  No se encontraron puertos COM\")\n    for puerto in puertos:\n        print(f\"   \u2022 {puerto.device}: {puerto.description}\")\n    print()\n\nlistar_puertos()\n\ntry:\n    esp32 = serial.Serial(esp32_port, baud_rate, timeout=1)\n    time.sleep(2)\n    print(f\" \u00a1Conectado al ESP32 en {esp32_port}!\")\nexcept serial.SerialException as e:\n    print(f\" Error de conexi\u00f3n serial: {e}\")\n    esp32 = None\nexcept Exception as e:\n    print(f\" Error inesperado: {e}\")\n    esp32 = None\n\nprint(\"=\" * 50)\n\n# ------------------- Configuraci\u00f3n c\u00e1mara -------------------\ncap = cv2.VideoCapture(1)\ncap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\ncap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n\nif not cap.isOpened():\n    print(\"Error: No se pudo abrir la c\u00e1mara\")\n    exit()\n\n# ------------------- Posici\u00f3n inicial servos -------------------\ncenter_angle = 90\ncurrent_x = center_angle\ncurrent_y = center_angle\nDEAD_ZONE = 15  # Zona muerta reducida\nsmoothing = 0.3  # Suavizado reducido para respuesta m\u00e1s r\u00e1pida\n\n# ------------------- Par\u00e1metros PID ajustables -------------------\nKp = 0.15\nKi = 0.001\nKd = 0.20\n\nprev_error_x = 0\nprev_error_y = 0\nintegral_x = 0\nintegral_y = 0\n\nMAX_INTEGRAL = 50\n\n# ------------------- Par\u00e1metros de detecci\u00f3n -------------------\n# Rango HSV para plataforma VERDE (modificado)\nLOW_GREEN = np.array([35, 40, 40])      # H: 35-85 (verde), S: m\u00ednimo 40, V: m\u00ednimo 40\nHIGH_GREEN = np.array([85, 255, 255])   # Rango amplio para captar diferentes tonos de verde\nAREA_MIN_PLATAFORMA = 1000  # \u00c1rea m\u00ednima del cuadrado\n\n# Rango HSV para pelota AMARILLA (modificado)\nLOW_YELLOW = np.array([20, 100, 100])    # H: 20-35 (amarillo), S: m\u00ednimo 100, V: m\u00ednimo 100\nHIGH_YELLOW = np.array([35, 255, 255])   # Cubre tonos amarillos brillantes\nAREA_MIN_PELOTA = 200\nRADIO_MIN_PELOTA = 8\n\n# ------------------- Funci\u00f3n para limitar valores -------------------\ndef constrain(value, min_val, max_val):\n    return max(min_val, min(max_val, value))\n\n# ------------------- Callbacks para sliders -------------------\ndef update_kp(val):\n    global Kp\n    Kp = val / 100.0  # Slider 0-100, valor real 0.00-1.00\n    print(f\"Kp = {Kp:.3f}\")\n\ndef update_ki(val):\n    global Ki\n    Ki = val / 1000.0  # Slider 0-100, valor real 0.000-0.100\n    print(f\"Ki = {Ki:.4f}\")\n\ndef update_kd(val):\n    global Kd\n    Kd = val / 100.0  # Slider 0-100, valor real 0.00-1.00\n    print(f\"Kd = {Kd:.3f}\")\n\n# ------------------- Crear ventana de control -------------------\ncv2.namedWindow('Control PID')\ncv2.createTrackbar('Kp x100', 'Control PID', int(Kp * 100), 100, update_kp)\ncv2.createTrackbar('Ki x1000', 'Control PID', int(Ki * 1000), 100, update_ki)\ncv2.createTrackbar('Kd x100', 'Control PID', int(Kd * 100), 100, update_kd)\n\nprev_time = time.time()\nprint(\"=\" * 50)\nprint(\"Sistema de Balance: Plataforma VERDE + Pelota AMARILLA\")\nprint(\"=\" * 50)\nprint(\"CONFIGURACI\u00d3N:\")\nprint(f\"  \u2022 Centro servos: {center_angle}\u00b0 (Rango: 0-180\u00b0)\")\nprint(f\"  \u2022 Zona muerta: \u00b1{DEAD_ZONE} p\u00edxeles\")\nprint(f\"  \u2022 Suavizado: {smoothing}\")\nprint(f\"  \u2022 PID: Kp={Kp} Ki={Ki} Kd={Kd}\")\nprint(\"\\nDETECCI\u00d3N:\")\nprint(\"  \u2022 PLATAFORMA VERDE (HSV): Detecta \u00e1rea m\u00e1s grande de tonos verdes\")\nprint(f\"    Rango H: {LOW_GREEN[0]}-{HIGH_GREEN[0]} | S: {LOW_GREEN[1]}-{HIGH_GREEN[1]} | V: {LOW_GREEN[2]}-{HIGH_GREEN[2]}\")\nprint(\"  \u2022 PELOTA AMARILLA: Posici\u00f3n para calcular error\")\nprint(f\"    Rango H: {LOW_YELLOW[0]}-{HIGH_YELLOW[0]} | S: {LOW_YELLOW[1]}-{HIGH_YELLOW[1]} | V: {LOW_YELLOW[2]}-{HIGH_YELLOW[2]}\")\nprint(\"\\nCONTROLES:\")\nprint(\"  \u2022 'q' \u2192 Salir\")\nprint(\"  \u2022 'c' \u2192 Resetear integrales\")\nprint(\"  \u2022 Sliders \u2192 Ajustar PID en tiempo real\")\nprint(\"=\" * 50)\n\nframe_count = 0\nfps_time = time.time()\nfps = 0\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret:\n        print(\"Error: No se pudo leer frame de la c\u00e1mara\")\n        break\n\n    frame = cv2.flip(frame, 1)\n    height, width = frame.shape[:2]\n    centrox, centroy = width//2, height//2\n\n    # ===============================================================\n    # DETECCI\u00d3N 1: PLATAFORMA VERDE (HSV) - \u00c1REA M\u00c1S GRANDE\n    # ===============================================================\n    hsv_plat = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n\n    # M\u00e1scara para detectar verde\n    mask_plataforma = cv2.inRange(hsv_plat, LOW_GREEN, HIGH_GREEN)\n\n    kernel_plat = np.ones((7,7), np.uint8)\n    mask_plataforma = cv2.morphologyEx(mask_plataforma, cv2.MORPH_CLOSE, kernel_plat)\n    mask_plataforma = cv2.morphologyEx(mask_plataforma, cv2.MORPH_OPEN, kernel_plat)\n    mask_plataforma = cv2.dilate(mask_plataforma, kernel_plat, iterations=1)\n\n    contours_plat, _ = cv2.findContours(mask_plataforma, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    area_max_plat = 0\n    contorno_plat = None\n    centro_plataforma = None\n    rectangulo_info = None\n\n    for c in contours_plat:\n        area = cv2.contourArea(c)\n        if area &gt; area_max_plat and area &gt; AREA_MIN_PLATAFORMA:\n            area_max_plat = area\n            contorno_plat = c\n            rectangulo_info = cv2.minAreaRect(c)\n\n            M = cv2.moments(c)\n            if M[\"m00\"] != 0:\n                cx_plat = int(M[\"m10\"] / M[\"m00\"])\n                cy_plat = int(M[\"m01\"] / M[\"m00\"])\n                centro_plataforma = (cx_plat, cy_plat)\n\n    # ===============================================================\n    # DETECCI\u00d3N 2: PELOTA AMARILLA\n    # ===============================================================\n    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    mask_pelota = cv2.inRange(hsv, LOW_YELLOW, HIGH_YELLOW)\n\n    kernel_pelota = np.ones((5,5), np.uint8)\n    mask_pelota = cv2.morphologyEx(mask_pelota, cv2.MORPH_OPEN, kernel_pelota)\n    mask_pelota = cv2.morphologyEx(mask_pelota, cv2.MORPH_CLOSE, kernel_pelota)\n    mask_pelota = cv2.dilate(mask_pelota, kernel_pelota, iterations=1)\n\n    contours_pelota, _ = cv2.findContours(mask_pelota, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    area_max_pelota = 0\n    contorno_pelota = None\n    centro_pelota = None\n    radio_pelota = 0\n\n    for c in contours_pelota:\n        area = cv2.contourArea(c)\n        if area &gt; area_max_pelota:\n            area_max_pelota = area\n            contorno_pelota = c\n            (x_pel, y_pel), radio_pelota = cv2.minEnclosingCircle(c)\n            if radio_pelota &gt; RADIO_MIN_PELOTA and area &gt; AREA_MIN_PELOTA:\n                centro_pelota = (int(x_pel), int(y_pel))\n\n    # ===============================================================\n    # VISUALIZACI\u00d3N\n    # ===============================================================\n    out_original = frame.copy()\n\n    mask_combinada = cv2.bitwise_or(mask_plataforma, mask_pelota)\n    out_deteccion = cv2.cvtColor(mask_combinada, cv2.COLOR_GRAY2BGR)\n\n    # Verde para plataforma, Amarillo para pelota\n    out_deteccion[mask_plataforma &gt; 0] = [0, 255, 0]      # Verde\n    out_deteccion[mask_pelota &gt; 0] = [0, 255, 255]        # Amarillo (BGR: cyan visualmente amarillo en HSV)\n\n    # ===============================================================\n    # CALCULAR TIEMPO\n    # ===============================================================\n    current_time = time.time()\n    dt = current_time - prev_time\n    prev_time = current_time\n    if dt &lt; 0.001:\n        dt = 0.001\n\n    # ===============================================================\n    # CONTROL PID\n    # ===============================================================\n    plataforma_detectada = (contorno_plat is not None and area_max_plat &gt; AREA_MIN_PLATAFORMA and centro_plataforma is not None)\n    pelota_detectada = (contorno_pelota is not None and centro_pelota is not None)\n\n    if plataforma_detectada:\n        if rectangulo_info:\n            box = cv2.boxPoints(rectangulo_info)\n            box = np.intp(box)\n            cv2.drawContours(out_original, [box], 0, (0, 255, 0), 3)\n            cv2.drawContours(out_deteccion, [box], 0, (0, 255, 0), 2)\n\n        cv2.circle(out_original, centro_plataforma, 12, (0, 255, 0), 3)\n        cv2.circle(out_original, centro_plataforma, 5, (0, 255, 0), -1)\n        cv2.putText(out_original, \"PLATAFORMA\", (centro_plataforma[0]-40, centro_plataforma[1]-20),\n                   cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)\n\n        if pelota_detectada:\n            cv2.circle(out_original, centro_pelota, int(radio_pelota), (0, 255, 255), 2)\n            cv2.circle(out_original, centro_pelota, 5, (0, 255, 255), -1)\n            cv2.putText(out_original, \"PELOTA\", (centro_pelota[0]-30, centro_pelota[1]+25),\n                       cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 2)\n            cv2.line(out_original, centro_plataforma, centro_pelota, (0, 255, 255), 2)\n            cv2.line(out_deteccion, centro_plataforma, centro_pelota, (255, 255, 255), 2)\n\n            # ===============================================================\n            # CALCULAR ERROR: Pelota respecto al centro de la plataforma\n            # ===============================================================\n            error_x = -(centro_pelota[0] - centro_plataforma[0])\n            error_y = (centro_pelota[1] - centro_plataforma[1])\n\n            if abs(error_x) &lt; DEAD_ZONE:\n                error_x = 0\n            if abs(error_y) &lt; DEAD_ZONE:\n                error_y = 0\n\n            integral_x += error_x * dt\n            integral_y += error_y * dt\n            integral_x = constrain(integral_x, -MAX_INTEGRAL, MAX_INTEGRAL)\n            integral_y = constrain(integral_y, -MAX_INTEGRAL, MAX_INTEGRAL)\n\n            derivative_x = (error_x - prev_error_x) / dt\n            derivative_y = (error_y - prev_error_y) / dt\n\n            output_x = Kp*error_x + Ki*integral_x + Kd*derivative_x\n            output_y = Kp*error_y + Ki*integral_y + Kd*derivative_y\n\n            prev_error_x = error_x\n            prev_error_y = error_y\n\n            delta_x = output_x * 0.15\n            delta_y = output_y * 0.15\n\n            target_x = center_angle + delta_x\n            target_y = center_angle + delta_y\n\n            current_x = current_x * (1 - smoothing) + target_x * smoothing\n            current_y = current_y * (1 - smoothing) + target_y * smoothing\n\n            current_x = constrain(current_x, 0, 110)\n            current_y = constrain(current_y, 0, 110)\n\n            if esp32:\n                mensaje = f\"{int(current_x)},{int(current_y)}\\n\"\n                try:\n                    esp32.write(mensaje.encode())\n                    if esp32.in_waiting &gt; 0:\n                        respuesta = esp32.readline().decode('utf-8', errors='ignore').strip()\n                        if respuesta and frame_count % 30 == 0:\n                            print(f\" ESP32: {respuesta}\")\n                except Exception as e:\n                    if frame_count % 30 == 0:\n                        print(f\"\u2717 Error: {e}\")\n\n            if frame_count % 5 == 0:\n                print(f\"\u2713 X={int(current_x):3d}\u00b0 Y={int(current_y):3d}\u00b0 | Err X={-error_x:4d} Y={-error_y:4d} | Out X={output_x:6.1f} Y={output_y:6.1f}\")\n\n            cv2.putText(out_original, f\"Error X:{-error_x} Y:{-error_y}\", (10,30),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,0), 2)\n            cv2.putText(out_original, f\"Servo X:{int(current_x)} Y:{int(current_y)}\", (10,60),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,0), 2)\n            cv2.putText(out_original, f\"Distancia: {int(np.sqrt(error_x**2 + error_y**2))} px\", (10,90),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0,255,255), 2)\n        else:\n            cv2.putText(out_original, \"PELOTA NO DETECTADA\", (10,30),\n                        cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,165,255), 2)\n\n            integral_x = 0\n            integral_y = 0\n            prev_error_x = 0\n            prev_error_y = 0\n\n            current_x = current_x * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n            current_y = current_y * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n\n            if esp32 and frame_count % 10 == 0:\n                try:\n                    esp32.write(f\"{int(current_x)},{int(current_y)}\\n\".encode())\n                except:\n                    pass\n\n            if frame_count % 30 == 0:\n                print(f\"\u26a0 Solo plataforma. Centrando: X={int(current_x)}\u00b0 Y={int(current_y)}\u00b0\")\n    else:\n        cv2.putText(out_original, \"PLATAFORMA NO DETECTADA\", (10,30),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,0,255), 2)\n\n        integral_x = 0\n        integral_y = 0\n        prev_error_x = 0\n        prev_error_y = 0\n\n        current_x = current_x * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n        current_y = current_y * (1 - smoothing*0.5) + center_angle * smoothing * 0.5\n\n        if esp32 and frame_count % 10 == 0:\n            try:\n                esp32.write(f\"{int(current_x)},{int(current_y)}\\n\".encode())\n            except:\n                pass\n\n        if frame_count % 30 == 0:\n            print(f\"\u26a0 Sin detecci\u00f3n. Centrando: X={int(current_x)}\u00b0 Y={int(current_y)}\u00b0\")\n\n    cv2.circle(out_original, (centrox, centroy), DEAD_ZONE, (128,128,128), 1)\n    cv2.line(out_original, (centrox-15, centroy), (centrox+15, centroy), (128,128,128), 1)\n    cv2.line(out_original, (centrox, centroy-15), (centrox, centroy+15), (128,128,128), 1)\n\n    cv2.putText(out_original, f\"Plat:{int(area_max_plat)} Pel:{int(area_max_pelota)}\", (10,height-40),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200,200,200), 1)\n\n    cv2.putText(out_original, f\"PID: Kp={Kp:.2f} Ki={Ki:.3f} Kd={Kd:.2f}\", (10,120),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,200,0), 2)\n\n    frame_count += 1\n    if time.time() - fps_time &gt; 1.0:\n        fps = frame_count\n        frame_count = 0\n        fps_time = time.time()\n\n    cv2.putText(out_original, f\"FPS: {fps}\", (width-100, 30),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,0), 2)\n\n    cv2.imshow(\"Sistema de Balance - Original\", out_original)\n    cv2.imshow(\"Deteccion: Plataforma(Verde) + Pelota(Amarillo)\", out_deteccion)\n\n    key = cv2.waitKey(1) &amp; 0xFF\n    if key == ord('q'):\n        break\n    elif key == ord('c'):\n        integral_x = 0\n        integral_y = 0\n        print(\"Integrales reseteadas\")\n\nprint(\"\\nCerrando sistema...\")\ncap.release()\nif esp32:\n    esp32.write(f\"{center_angle},{center_angle}\\n\".encode())\n    time.sleep(0.1)\n    esp32.close()\n    print(\"Conexi\u00f3n serial cerrada\")\ncv2.destroyAllWindows()\nprint(\"Sistema finalizado\")\n</code></pre>"},{"location":"Proyecto%20Final%20del%20semestre/#codigo-arduino-fragmento-de-procesamiento","title":"C\u00f3digo Arduino (Fragmento de Procesamiento)","text":"<pre><code>#include &lt;ESP32Servo.h&gt;\n#include &lt;BluetoothSerial.h&gt;\n\n// =============== CONFIGURACI\u00d3N BLUETOOTH ===============\nString device_name = \"ESP32-BT-Slave\";\nBluetoothSerial SerialBT;\n\n// =============== CONFIGURACI\u00d3N DE PINES ===============\nconst int PIN_SERVO_X = 18;\nconst int PIN_SERVO_Y = 19;\n\n// =============== CONFIGURACI\u00d3N DE SERVOS ===============\nServo servoX;\nServo servoY;\n\nconst int PWM_MIN = 500;\nconst int PWM_MAX = 2400;\n\n// =============== POSICI\u00d3N INICIAL (CENTRADA) ===============\nconst int CENTRO = 90;\n\n// =============== VARIABLES DE COMUNICACI\u00d3N ===============\nString inputString = \"\";\nbool stringComplete = false;\n\n// =============== VARIABLES DE CONTROL ===============\nint posicionX = CENTRO;\nint posicionY = CENTRO;\nunsigned long ultimoComando = 0;\nconst unsigned long TIMEOUT = 2000;\n\n// =============== VARIABLES DE DEBUG ===============\nunsigned long contadorComandos = 0;\nunsigned long ultimoDebug = 0;\nconst unsigned long INTERVALO_DEBUG = 1000;\n\n// =============== CONFIGURACI\u00d3N INICIAL ===============\nvoid setup() {\n  // Iniciar Serial USB (para debug)\n  Serial.begin(115200);\n  delay(100);\n\n  // Iniciar Bluetooth Serial\n  SerialBT.begin(device_name);\n  delay(500);\n\n  inputString.reserve(20);\n\n  // Configurar timers del ESP32\n  ESP32PWM::allocateTimer(0);\n  ESP32PWM::allocateTimer(1);\n  ESP32PWM::allocateTimer(2);\n  ESP32PWM::allocateTimer(3);\n\n  // Configurar servos\n  servoX.attach(PIN_SERVO_X, PWM_MIN, PWM_MAX);\n  servoY.attach(PIN_SERVO_Y, PWM_MIN, PWM_MAX);\n\n  // Mover a posici\u00f3n inicial (CENTRO)\n  Serial.println(\"\\n========================================\");\n  Serial.println(\"Inicializando servos en posicion central...\");\n  servoX.write(CENTRO);\n  servoY.write(CENTRO);\n  delay(1000);\n  Serial.println(\"Servos centrados!\");\n\n  // Mensaje de inicio (USB)\n  Serial.println(\"========================================\");\n  Serial.println(\"ESP32 - Sistema de Balance BLUETOOTH\");\n  Serial.println(\"========================================\");\n  Serial.print(\"Nombre Bluetooth: \");\n  Serial.println(device_name);\n  Serial.print(\"Servo X en GPIO \");\n  Serial.println(PIN_SERVO_X);\n  Serial.print(\"Servo Y en GPIO \");\n  Serial.println(PIN_SERVO_Y);\n  Serial.print(\"Posicion inicial: \");\n  Serial.print(CENTRO);\n  Serial.println(\" grados\");\n  Serial.println(\"========================================\");\n  Serial.println(\"Esperando conexion Bluetooth...\");\n  Serial.println(\"========================================\\n\");\n\n  // Mensaje de inicio (Bluetooth)\n  SerialBT.println(\"ESP32 Balance System Ready\");\n  SerialBT.println(\"Servos centrados en 90 grados\");\n  SerialBT.println(\"Esperando comandos...\");\n\n  ultimoComando = millis();\n  ultimoDebug = millis();\n}\n\n// =============== BUCLE PRINCIPAL ===============\nvoid loop() {\n  // Leer datos desde Bluetooth\n  while (SerialBT.available()) {\n    char inChar = (char)SerialBT.read();\n\n    if (inChar == '\\n' || inChar == '\\r') {\n      if (inputString.length() &gt; 0) {\n        stringComplete = true;\n      }\n    } else {\n      inputString += inChar;\n    }\n  }\n\n  // Procesar comando si est\u00e1 completo\n  if (stringComplete) {\n    procesarComando();\n    inputString = \"\";\n    stringComplete = false;\n    ultimoComando = millis();\n  }\n\n  // Debug peri\u00f3dico (solo por USB)\n  if (millis() - ultimoDebug &gt; INTERVALO_DEBUG) {\n    mostrarEstado();\n    ultimoDebug = millis();\n  }\n\n  // Timeout - volver al centro si no hay comandos\n  if (millis() - ultimoComando &gt; TIMEOUT) {\n    volverAlCentro();\n  }\n}\n\n// =============== FUNCI\u00d3N: PROCESAR COMANDO ===============\nvoid procesarComando() {\n  contadorComandos++;\n\n  // Debug por USB\n  Serial.print(\"[BT-CMD #\");\n  Serial.print(contadorComandos);\n  Serial.print(\"] '\");\n  Serial.print(inputString);\n  Serial.print(\"' -&gt; \");\n\n  int comaIndex = inputString.indexOf(',');\n\n  if (comaIndex &gt; 0) {\n    String valorXStr = inputString.substring(0, comaIndex);\n    String valorYStr = inputString.substring(comaIndex + 1);\n\n    int xRecibido = valorXStr.toInt();\n    int yRecibido = valorYStr.toInt();\n\n    // Debug\n    Serial.print(\"X=\");\n    Serial.print(xRecibido);\n    Serial.print(\" Y=\");\n    Serial.print(yRecibido);\n\n    // Validar y limitar (0-180 grados)\n    xRecibido = constrain(xRecibido, 0, 180);\n    yRecibido = constrain(yRecibido, 0, 180);\n\n    // Mostrar cambio\n    if (xRecibido != posicionX || yRecibido != posicionY) {\n      Serial.print(\" | Moviendo: X(\");\n      Serial.print(posicionX);\n      Serial.print(\"\u2192\");\n      Serial.print(xRecibido);\n      Serial.print(\"\u00b0) Y(\");\n      Serial.print(posicionY);\n      Serial.print(\"\u2192\");\n      Serial.print(yRecibido);\n      Serial.println(\"\u00b0)\");\n    } else {\n      Serial.println(\" | Sin cambio\");\n    }\n\n    // Actualizar posiciones\n    posicionX = xRecibido;\n    posicionY = yRecibido;\n\n    // Mover servos a las nuevas posiciones\n    servoX.write(posicionX);\n    servoY.write(posicionY);\n\n    // Confirmaci\u00f3n por Bluetooth a Python\n    SerialBT.print(\"OK: \");\n    SerialBT.print(posicionX);\n    SerialBT.print(\",\");\n    SerialBT.println(posicionY);\n\n  } else {\n    Serial.println(\"ERROR - Formato invalido\");\n    SerialBT.println(\"Error: Formato invalido. Use X,Y\");\n  }\n}\n\n// =============== FUNCI\u00d3N: MOSTRAR ESTADO ===============\nvoid mostrarEstado() {\n  if (SerialBT.hasClient()) {\n    Serial.print(\"[ESTADO] BT conectado | X=\");\n  } else {\n    Serial.print(\"[ESTADO] BT desconectado | X=\");\n  }\n  Serial.print(posicionX);\n  Serial.print(\"\u00b0 Y=\");\n  Serial.print(posicionY);\n  Serial.print(\"\u00b0 | Cmds: \");\n  Serial.print(contadorComandos);\n  Serial.print(\" | Sin datos: \");\n  Serial.print((millis() - ultimoComando) / 1000);\n  Serial.println(\"s\");\n}\n\n// =============== FUNCI\u00d3N: VOLVER AL CENTRO ===============\nvoid volverAlCentro() {\n  static bool mensajeMostrado = false;\n  static unsigned long ultimoCentrado = 0;\n\n  if (millis() - ultimoCentrado &lt; 500) {\n    return;\n  }\n  ultimoCentrado = millis();\n\n  if (posicionX != CENTRO || posicionY != CENTRO) {\n    if (!mensajeMostrado) {\n      Serial.println(\"\\n[TIMEOUT] Volviendo al centro...\");\n      SerialBT.println(\"Timeout: Centrando servos...\");\n      mensajeMostrado = true;\n    }\n\n    // Movimiento gradual al centro\n    if (posicionX &lt; CENTRO) posicionX += 2;\n    if (posicionX &gt; CENTRO) posicionX -= 2;\n    if (posicionY &lt; CENTRO) posicionY += 2;\n    if (posicionY &gt; CENTRO) posicionY -= 2;\n\n    // Ajuste fino\n    if (abs(posicionX - CENTRO) == 1) posicionX = CENTRO;\n    if (abs(posicionY - CENTRO) == 1) posicionY = CENTRO;\n\n    servoX.write(posicionX);\n    servoY.write(posicionY);\n\n    Serial.print(\"  Centrando: X=\");\n    Serial.print(posicionX);\n    Serial.print(\"\u00b0 Y=\");\n    Serial.print(posicionY);\n    Serial.println(\"\u00b0\");\n  } else {\n    if (mensajeMostrado) {\n      Serial.println(\"[CENTRADO] Completo\\n\");\n      mensajeMostrado = false;\n      ultimoComando = millis();\n    }\n  }\n</code></pre>"},{"location":"Proyecto%20Final%20del%20semestre/#6-resultados-y-conclusiones-del-proyecto-final","title":"6. Resultados y Conclusiones del Proyecto Final","text":""},{"location":"Proyecto%20Final%20del%20semestre/#61-resultados-clave-validacion-de-subsistemas","title":"6.1. Resultados Clave: Validaci\u00f3n de Subsistemas","text":"<p>La validaci\u00f3n del proyecto se centr\u00f3 en demostrar el funcionamiento y la integraci\u00f3n exitosa de los tres subsistemas principales:</p> <ul> <li> <p>Detecci\u00f3n y Precisi\u00f3n de la Visi\u00f3n (Subsistema Sensor):</p> <ul> <li>La Visi\u00f3n por Computadora (Python/OpenCV) calcul\u00f3 el Error de Posici\u00f3n (<code>x</code>, <code>y</code>) con la precisi\u00f3n necesaria para la tarea de balanceo. </li> <li>La implementaci\u00f3n de la segmentaci\u00f3n HSV y la morfolog\u00eda asegur\u00f3 una detecci\u00f3n estable de la pelota y la plataforma, proporcionando datos de entrada confiables para el control.</li> </ul> </li> <li> <p>Conectividad y Latencia (Subsistema Comunicaci\u00f3n):</p> <ul> <li>Se estableci\u00f3 y mantuvo una conexi\u00f3n Bluetooth estable entre la PC y la ESP32.</li> <li>La baja latencia en la transmisi\u00f3n de datos permiti\u00f3 que los comandos de correcci\u00f3n llegaran al microcontrolador a una velocidad suficiente para ejecutar correcciones r\u00e1pidas y din\u00e1micas de la plataforma, validando la arquitectura PC-ESP32.</li> </ul> </li> <li> <p>Control de Posici\u00f3n (Subsistema Actuaci\u00f3n):</p> <ul> <li>El sistema demostr\u00f3 ser capaz de llevar la pelota desde una posici\u00f3n inicial descentrada hacia el punto de equilibrio central (Set-Point).</li> <li>El ajuste fino del PID, junto con la Zona Muerta y el Suavizado, logr\u00f3 el objetivo principal: mantener la pelota en equilibrio sobre la plataforma por un tiempo prolongado, contrarrestando las perturbaciones de manera eficiente.</li> </ul> </li> </ul>"},{"location":"Proyecto%20Final%20del%20semestre/#62-conclusion-del-proyecto","title":"6.2. Conclusi\u00f3n del Proyecto","text":"<p>El proyecto de la Plataforma de Balanceo de Bola demostr\u00f3 la aplicaci\u00f3n efectiva de la Ingenier\u00eda de Control y la Visi\u00f3n por Computadora en un sistema mecatr\u00f3nico funcional. Se logr\u00f3 integrar con \u00e9xito tres dominios: 1.  El procesamiento de alto nivel (Python/OpenCV). 2.  La comunicaci\u00f3n inal\u00e1mbrica (Bluetooth). 3.  El control de actuadores de precisi\u00f3n (Servomotores/ESP32).</p>"},{"location":"Proyecto%20Final%20del%20semestre/#fotos-y-videos","title":"Fotos y videos","text":"Tu navegador no soporta la reproducci\u00f3n de video."},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/","title":"Visi\u00f3n por Computadora: Manipulaci\u00f3n de Video y Tracking de Objetos (Python/OpenCV)","text":"<p>Esta secci\u00f3n documenta diversas pr\u00e1cticas de Visi\u00f3n por Computadora realizadas con Python y la librer\u00eda OpenCV (cv2). Los ejercicios demuestran la capacidad de adquirir streams de video en tiempo real, aplicar filtros de procesamiento de im\u00e1genes, superponer gr\u00e1ficos y, finalmente, implementar un sistema avanzado de seguimiento de objetos por color con capacidad de control externo mediante Bluetooth.</p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#entornos","title":"Entornos","text":""},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#1-captura-basica-y-visualizacion","title":"1. Captura b\u00e1sica y visualizaci\u00f3n","text":"<p>Establece la conexi\u00f3n con la c\u00e1mara (cv2.VideoCapture(0)) y muestra el stream hasta que se presiona la tecla 'q'. </p> <p>cpp import cv2 </p> <p>video = cv2.VideoCapture(0) </p> <p>while True:     ret, frame = video.read()     if not ret:         break </p> <p>cv2.imshow(\"Video\", frame)  </p> <p># Salida del bucle     if cv2.waitKey(1) &amp; 0xFF == ord('q'):        break </p> <p>video.release() cv2.destroyAllWindows() </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#11-conversion-a-bn","title":"1.1 Conversion a B/N","text":"<p>Aplica un filtro de color para transformar el video capturado a escala de grises, reduciendo la complejidad de la imagen a una sola dimensi\u00f3n de intensidad. Este es un paso fundamental en muchos algoritmos de visi\u00f3n por computadora para la detecci\u00f3n de bordes y el procesamiento eficiente. </p> <p></p> <p>cpp import cv2 </p> <p>video = cv2.VideoCapture(0)  while True:     ret, frame = video.read()     if not ret:         break </p> <p>dibujo = frame.copy()  </p> <p># Convertir el fotograma a escala de grises     dibujo = cv2.cvtColor(dibujo, cv2.COLOR_BGR2GRAY)  </p> <p>cv2.imshow(\"Video\", frame)    cv2.imshow(\"VIDEO_GRIS\", dibujo) </p> <p>if cv2.waitKey(1) &amp; 0xFF == ord('q'):         break </p> <p>video.release()  cv2.destroyAllWindows() </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#2-manipulacion-de-color","title":"2. Manipulaci\u00f3n de color","text":""},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#21-tonos-azules-y-rgb-bgr","title":"2.1 Tonos azules y RGB -&gt; BGR","text":"<p>Al convertir de BGR (formato nativo de OpenCV) a RGB (formato est\u00e1ndar de visualizaci\u00f3n), el orden de los canales se invierte. Esta reordenaci\u00f3n produce un predominio de tonos azules y cianes en la visualizaci\u00f3n, ya que los valores asignados al canal Azul se mueven al canal Rojo (\u00edndice 2) y viceversa. </p> <p></p> <p>cpp import cv2 </p> <p>video = cv2.VideoCapture(0)  while True:     ret, frame = video.read()     if not ret:         break </p> <p>dibujo = frame.copy()  </p> <p># Conversi\u00f3n simple BGR a RGB (Reordenamiento de canales)     dibujo = cv2.cvtColor(dibujo, cv2.COLOR_BGR2RGB)  </p> <p>cv2.imshow(\"ORIGINAL\", frame)     cv2.imshow(\"FILTRO AZUL\", dibujo) </p> <p>if cv2.waitKey(1) &amp; 0xFF == ord('q'):         break </p> <p>video.release()  cv2.destroyAllWindows() </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#22-filtro-amarillo","title":"2.2 Filtro Amarillo","text":"<p>Para generar una fuerte predominancia de tonos amarillos y rojos (que combinados tienden al amarillo), se anula completamente el canal Azul. En la matriz de imagen BGR utilizada por OpenCV, el canal Azul se encuentra en el \u00edndice 0. </p> <p>cpp import cv2  import numpy as np </p> <p>video = cv2.VideoCapture(0)  while True:     ret, frame = video.read()     if not ret:         break </p> <p>dibujo = frame.copy()  </p> <p># Anular el canal azul: [:, :, 0] = 0     # Esto deja activos solo los canales Verde (1) y Rojo (2), resultando en tonos amarillos.     dibujo[:, :, 0] = 0  </p> <p>cv2.imshow(\"ORIGINAL\", frame)     cv2.imshow(\"FILTRO AMARILLO\", dibujo) </p> <p>if cv2.waitKey(1) &amp; 0xFF == ord('q'):         break </p> <p>video.release()  cv2.destroyAllWindows() </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#23-tonos-rosados","title":"2.3 Tonos Rosados","text":"<p>Para obtener una dominante de tonos rosados o magenta, se utiliza la combinaci\u00f3n de los canales Rojo y Azul mientras se anula completamente el canal Verde. En la matriz BGR de OpenCV, el canal Verde se encuentra en el \u00edndice 1. </p> <p></p> <p>cpp import cv2  import numpy as np </p> <p>video = cv2.VideoCapture(0)  while True:     ret, frame = video.read()     if not ret:         break </p> <p>dibujo = frame.copy()  </p> <p># Anular el canal verde: [:, :, 1] = 0     # Esto deja activos solo los canales Azul (0) y Rojo (2), resultando en tonos magenta/rosados.     dibujo[:, :, 1] = 0  </p> <p>cv2.imshow(\"ORIGINAL\", frame)     cv2.imshow(\"FILTRO ROSA\", dibujo) </p> <p>if cv2.waitKey(1) &amp; 0xFF == ord('q'):         break </p> <p>video.release()  cv2.destroyAllWindows() </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#superponer-figuras","title":"Superponer figuras","text":"<p>Esta secci\u00f3n demuestra la capacidad de dibujar figuras geom\u00e9tricas (l\u00edneas, rect\u00e1ngulos, c\u00edrculos) y texto sobre los fotogramas del video en tiempo real. Esta t\u00e9cnica es esencial para el tracking, ya que permite visualizar el centro de los objetos, las \u00e1reas de inter\u00e9s (ROI) o los cuadros delimitadores. </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#dibujo-de-linea-y-rectangulo","title":"Dibujo de l\u00ednea y rect\u00e1ngulo","text":"<p>Este script dibuja una l\u00ednea diagonal de esquina a esquina y un rect\u00e1ngulo delimitador que enmarca el video. </p> <p></p> <p>cpp import cv2 </p> <p>video = cv2.VideoCapture(0)  while True:     ret, frame = video.read()     if not ret:         break </p> <p>dibujo = frame.copy() </p> <p># L\u00ednea diagonal: Dibuja una l\u00ednea roja desde la esquina superior izquierda (0,0) a la inferior derecha (640, 480).     cv2.line(dibujo, (0, 0), (640, 480), (0, 0, 225), thickness=3, lineType=cv2.LINE_AA)  </p> <p># Rect\u00e1ngulo de marco: Dibuja un rect\u00e1ngulo azul alrededor del borde de la imagen.     cv2.rectangle(dibujo, (0, 0), (640, 480), (255, 0, 0), thickness=10, lineType=cv2.LINE_AA)  </p> <p>cv2.imshow(\"Video\", frame)     cv2.imshow(\"VIDEO02\", dibujo) </p> <p>if cv2.waitKey(1) &amp; 0xFF == ord('q'):         break </p> <p>video.release()  cv2.destroyAllWindows() </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#32-linea-rectangulo-circulo-y-animacion","title":"3.2 L\u00ednea, Rect\u00e1ngulo, C\u00edrculo y Animaci\u00f3n","text":"<p>Este ejercicio combina varias figuras geom\u00e9tricas y introduce el concepto de animaci\u00f3n usando variables din\u00e1micas (cx, cy). La actualizaci\u00f3n constante de estas variables simula el movimiento del c\u00edrculo a trav\u00e9s del frame, lo cual representa un concepto clave para visualizar el centro de un objeto en movimiento en aplicaciones de tracking. </p> <p></p> <p>cpp import cv2 </p> <p>video = cv2.VideoCapture(0)  cx = 0 cy = 0  </p> <p>while True:     ret, frame = video.read()     if not ret:         break </p> <p>dibujo = frame.copy() </p> <p># Figuras est\u00e1ticas     cv2.line(dibujo, (0, 0), (640, 480), (0, 0, 225), thickness=3, lineType=cv2.LINE_AA)     cv2.rectangle(dibujo, (0, 0), (640, 480), (255, 0, 0), thickness=10, lineType=cv2.LINE_AA) </p> <p># C\u00edrculo animado (centro en cx, cy)     cv2.circle(dibujo, (cx, cy), 100, (255, 0, 0), thickness=10, lineType=cv2.LINE_AA) </p> <p># Texto Fijo     cv2.putText(dibujo, \"TEXTO FIJO\", (320, 240), cv2.FONT_HERSHEY_SIMPLEX, 2, (255, 0, 0), thickness=2, lineType=cv2.LINE_AA) </p> <p># Actualizaci\u00f3n de posici\u00f3n para animaci\u00f3n     # El operador m\u00f3dulo (%) asegura que la posici\u00f3n se reinicie al llegar al borde (640x480).     cx = (cx + 1) % 640    cy = (cy + 1) % 480  </p> <p>cv2.imshow(\"Video\", frame)     cv2.imshow(\"VIDEO02\", dibujo) </p> <p>if cv2.waitKey(1) &amp; 0xFF == ord('q'):         break </p> <p>video.release()  cv2.destroyAllWindows() </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#33-division-de-la-camara-por-secciones-de-color","title":"3.3 Division de la camara por secciones de color","text":"<p>Este ejercicio demuestra el concepto de Regi\u00f3n de Inter\u00e9s (ROI) a trav\u00e9s de la indexaci\u00f3n de matrices de NumPy. Se aplica un filtro de color diferente a cada cuadrante del frame al anular selectivamente un canal de color en una porci\u00f3n espec\u00edfica de la matriz de la imagen. </p> <p></p> <p>cpp import cv2  import numpy as np </p> <p>video = cv2.VideoCapture(0)  while True:     ret, frame = video.read()     if not ret:         break </p> <p>dibujo = frame.copy()  </p> <p># Cuadrante 1 (Superior Izquierdo): Anular Canal Verde     # Esto resulta en tonos magenta/rosados (Rojo + Azul).     # Coordenadas: [Filas 0:240 (Y), Columnas 0:320 (X), Canal Verde (1)] = 0     dibujo[0:240, 0:320, 1] = 0  </p> <p># Cuadrante 2 (Inferior Derecho): Anular Canal Azul     # Esto resulta en tonos amarillos (Rojo + Verde).     # Coordenadas: [Filas 240:480 (Y), Columnas 320:640 (X), Canal Azul (0)] = 0     dibujo[240:480, 320:640, 0] = 0 </p> <p>cv2.imshow(\"Video\", frame)    cv2.imshow(\"VIDEO02\", dibujo) </p> <p>if cv2.waitKey(1) &amp; 0xFF == ord('q'):         break </p> <p>video.release()  cv2.destroyAllWindows() </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#seguimiento-de-objeto-y-control-remoto","title":"Seguimiento de objeto y control remoto","text":"<p>Estos c\u00f3digos aplican la segmentaci\u00f3n por color HSV y el c\u00e1lculo de contornos para localizar el objeto m\u00e1s grande en el frame y calcular su desviaci\u00f3n respecto al centro. Esto simula la l\u00f3gica de un sistema de seguimiento que podr\u00eda ser utilizado para controlar un sistema rob\u00f3tico. </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#deteccion-y-tracking-por-color","title":"Deteccion y tracking por color","text":"<p>Este script localiza un objeto de color azul espec\u00edfico, calcula su posici\u00f3n (x, y) y la compara con el centro del frame para determinar el error direccional (ErrorX, ErrorY), imprimi\u00e9ndolo en la consola.  </p> <p>cpp import cv2  import numpy as np  import time </p> <p>video = cv2.VideoCapture(0) </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#rango-de-color-azul-en-hsv","title":"Rango de color azul en HSV","text":"<p>bajo = np.array([90, 50, 20], dtype=np.uint8)  alto = np.array([145, 255, 255], dtype=np.uint8) </p> <p>while True:     ret, frame = video.read()     if not ret:         break </p> <p>dibujo = frame.copy()     hsv = cv2.cvtColor(dibujo, cv2.COLOR_BGR2HSV) </p> <p># 1. Segmentaci\u00f3n por Color (M\u00e1scara)     mask = cv2.inRange(hsv, bajo, alto)     result = cv2.bitwise_and(frame, frame, mask=mask) </p> <p># 2. Encontrar Contornos     lista_cont, herarquia = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) </p> <p># 3. Identificar el Contorno M\u00e1s Grande (el objeto de inter\u00e9s principal)     area_grande = 0     contorno_pelota = None     if lista_cont:         for contn in lista_cont:             area = cv2.contourArea(contn)             if (area &gt; area_grande):                 area_grande = area                 contorno_pelota = contn </p> <p># 4. Calcular Centro y Radio del C\u00edrculo Envolvente     if contorno_pelota is not None:         (x,y),radio = cv2.minEnclosingCircle(contorno_pelota) </p> <pre><code>   # Dibujar el c\u00edrculo y el punto central de seguimiento \n   cv2.circle(frame,(int(x),int(y)),int(radio),(0,255,0),3) \n   cv2.circle(frame,(int(x),int(y)),3, (0,255,0),3)\n\n   # 5. Calcular el Error (Desviaci\u00f3n respecto al centro del frame) \n   h = frame.shape[0]  \n   w = frame.shape[1]\n\n   errorx = x - (w / 2)  \n   errory = y - (h / 2)\n\n   print(f\"ErrorX: {errorx:.1f}, ErrorY: {errory:.1f}\")\n\n   # 6. Imprimir la Direcci\u00f3n de Correcci\u00f3n (L\u00f3gica de control) \n   if (errorx &gt; 0): \n       print(\"IZQUIERDA\") # El objeto est\u00e1 a la derecha del centro (ErrorX positivo), el robot debe girar a la IZQUIERDA. \n   elif(errorx &lt; 0): \n       print(\"DERECHA\") # El objeto est\u00e1 a la izquierda del centro (ErrorX negativo), el robot debe girar a la DERECHA.\n\n   if (errory &gt; 0): \n       print(\"ABAJO\") \n   elif(errory &lt; 0): \n       print(\"ARRIBA\")\n</code></pre> <p>time.sleep(0.5) </p> <p># Visualizaciones en tiempo real     cv2.imshow(\"MASK (Blanco: Azul detectado)\", mask)     cv2.imshow(\"Objeto Azul sobre Fondo Negro\", result)     cv2.imshow(\"Video Original (Tracking)\", frame) </p> <p>if cv2.waitKey(1) &amp; 0xFF == ord('q'):         break </p> <p>video.release()  cv2.destroyAllWindows() </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#42-tracking-con-bluetooth","title":"4.2 Tracking con Bluetooth","text":"<p>Este es el ejercicio m\u00e1s avanzado, ya que extiende la l\u00f3gica de tracking local a\u00f1adiendo la comunicaci\u00f3n serial inal\u00e1mbrica mediante un socket Bluetooth. El script env\u00eda comandos direccionales (IZQUIERDA, DERECHA, CENTRO, etc.) a un dispositivo externo (como un microcontrolador ESP32 o Arduino con m\u00f3dulo Bluetooth), permitiendo el control aut\u00f3nomo de un robot o actuador basado en la visi\u00f3n por computadora. </p> <p>cpp import cv2  import numpy as np  import time  import bluetooth  </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#conexion-bluetooth-con-esp32","title":"======== CONEXI\u00d3N BLUETOOTH CON ESP32 ========","text":"<p>port = 1 </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#crea-el-socket-bluetooth-usando-el-protocolo-rfcomm-usado-para-serial","title":"Crea el socket Bluetooth usando el protocolo RFCOMM (usado para serial)","text":"<p>sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM) sock.settimeout(20) </p> <p>MAC_ADDRESS = \"10:06:1C:97:72:DA\" # &lt;-- \u00a1REEMPLAZAR CON TU DIRECCI\u00d3N MAC! </p> <p>print(\"Intentando conectar con el ESP32...\")  while True:     try:         # Intenta conectar con la direcci\u00f3n MAC y el puerto especificados         sock.connect((MAC_ADDRESS, port))        print(\"\u00a1Conectado al ESP32!\")         break     except Exception as e:         print(f\"Error en la conexi\u00f3n. Reintentando: {e}\")     time.sleep(1) </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#configuracion-de-la-camara-y-deteccion","title":"======== CONFIGURACI\u00d3N DE LA C\u00c1MARA Y DETECCI\u00d3N ========","text":"<p>video = cv2.VideoCapture(0) </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#rango-de-color-azul-en-hsv_1","title":"Rango de color azul en HSV","text":"<p>bajo = np.array([90, 50, 20], dtype=np.uint8)  alto = np.array([145, 255, 255], dtype=np.uint8) </p> <p>while True:     ret, frame = video.read()     if not ret:         break </p> <p>dibujo = frame.copy()     hsv = cv2.cvtColor(dibujo, cv2.COLOR_BGR2HSV)     mask = cv2.inRange(hsv, bajo, alto)     result = cv2.bitwise_and(frame, frame, mask=mask) </p> <p>lista_cont, herarquia = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) </p> <p># L\u00f3gica de Detecci\u00f3n de Contorno (Buscar el m\u00e1s grande)     if len(lista_cont) &gt; 0:         area_grande = 0         contorno_pelota = None         for contn in lista_cont:             area = cv2.contourArea(contn)             if area &gt; area_grande:                 area_grande = area                 contorno_pelota = contn </p> <pre><code>   if contorno_pelota is not None: \n       (x, y), radio = cv2.minEnclosingCircle(contorno_pelota)\n\n       # Dibujar en el frame para visualizaci\u00f3n \n       cv2.circle(frame, (int(x), int(y)), int(radio), (0, 255, 0), 3) \n       cv2.circle(frame, (int(x), int(y)), 3, (0, 255, 0), 3)\n\n       h = frame.shape[0] \n       w = frame.shape[1]\n\n       errorx = x - (w / 2) # Desviaci\u00f3n horizontal \n       errory = y - (h / 2) # Desviaci\u00f3n vertical\n\n       # ======== ENV\u00cdO DE COMANDOS AL ESP32 ======== \n       try: \n           # Umbrales de correcci\u00f3n (50 p\u00edxeles): Evita el \"ruido\" \n           if errorx &gt; 50: \n               mensaje = \"IZQUIERDA\"  \n           elif errorx &lt; -50: \n               mensaje = \"DERECHA\"  \n           elif errory &lt; -50: \n               mensaje = \"ARRIBA\"  \n           elif errory &gt; 50: \n               mensaje = \"ABAJO\"  \n           else: \n               mensaje = \"CENTRO\"\n\n           # Env\u00edo del mensaje codificado a trav\u00e9s del socket \n           sock.send(mensaje.encode('utf-8')) \n           print(\"Enviado:\", mensaje)\n\n       except Exception as e: \n           print(\"Error al enviar datos:\", e)\n</code></pre> <p># ======== MOSTRAR RESULTADOS ========     cv2.imshow(\"MASK (Blanco: Azul detectado)\", mask)     cv2.imshow(\"Objeto Azul sobre Fondo Negro\", result)     cv2.imshow(\"Video Original (Tracking + Bluetooth)\", frame) </p> <p>if cv2.waitKey(1) &amp; 0xFF == ord('q'):         break </p> <p>time.sleep(0.3) # Controla la velocidad de procesamiento y comandos </p> <p>video.release()  cv2.destroyAllWindows()  sock.close() # Cierra la conexi\u00f3n Bluetooth </p>"},{"location":"Visi%C3%B3n%20por%20Computadora%20con%20Python%20y%20OpenCV/#conclusion-y-futuro","title":"Conclusion y futuro","text":"<p>El desarrollo de este portafolio subraya la capacidad esencial de OpenCV y Python para transformar una fuente de video cruda en datos procesables, abarcando desde la manipulaci\u00f3n b\u00e1sica de p\u00edxeles (filtros y conversi\u00f3n de color BGR a HSV) hasta la implementaci\u00f3n de complejos algoritmos de Visi\u00f3n por Computadora (CV) para el seguimiento de objetos (tracking). La pr\u00e1ctica m\u00e1s significativa fue la exitosa integraci\u00f3n de la CV con la comunicaci\u00f3n inal\u00e1mbrica (Bluetooth), demostrando c\u00f3mo calcular el error direccional (ErrorX, ErrorY) de un objeto de inter\u00e9s y convertir esa desviaci\u00f3n en comandos de control (IZQUIERDA, DERECHA). Este proceso establece un puente funcional entre el mundo digital (visi\u00f3n) y el mundo f\u00edsico (rob\u00f3tica), siendo el principio rector de los sistemas de automatizaci\u00f3n y el control rob\u00f3tico basado en visi\u00f3n.</p>"},{"location":"control%20de%20led%20con%20ESP32/","title":"Control de LED con ESP32 (bot\u00f3n, Bluetooth e intervalos)","text":""},{"location":"control%20de%20led%20con%20ESP32/#1-resumen","title":"1) Resumen","text":"<p>Nombre del proyecto: Control de LED con ESP32 Equipo / Autor(es): Jos\u00e9 Ismael Guerrero Rom\u00e1n y Gerardo Esquivel De Luna Curso / Asignatura: Introducci\u00f3n a la Mecatr\u00f3nica Fecha: 19/09/25 Descripci\u00f3n breve: Se program\u00f3 un microcontrolador ESP32 para controlar un LED en tres casos distintos: mediante un bot\u00f3n f\u00edsico, a trav\u00e9s de comandos enviados por Bluetooth y con parpadeo autom\u00e1tico en intervalos de tiempo definidos.  </p>"},{"location":"control%20de%20led%20con%20ESP32/#2-objetivos","title":"2) Objetivos","text":"<p>General: Explorar diferentes formas de control de un LED con ESP32 aplicando entradas f\u00edsicas, comunicaci\u00f3n inal\u00e1mbrica y programaci\u00f3n de temporizaci\u00f3n.  </p> <p>Espec\u00edficos: - OE1: Programar el ESP32 para que un bot\u00f3n controle el encendido y apagado inmediato del LED. - OE2: Configurar la comunicaci\u00f3n Bluetooth del ESP32 para que el LED responda a comandos enviados desde la terminal (<code>\"on\"</code> y <code>\"off\"</code>). - OE3: Implementar un programa que haga parpadear el LED en intervalos de tiempo definidos. - OE4: Documentar con fotograf\u00edas y videos el c\u00f3digo y el funcionamiento de cada caso.  </p>"},{"location":"control%20de%20led%20con%20ESP32/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<p>Incluye: - Programaci\u00f3n del ESP32 en Arduino IDE (o entorno equivalente). - Caso 1: Control mediante bot\u00f3n f\u00edsico. - Caso 2: Control mediante Bluetooth con comandos <code>\"on\"</code> y <code>\"off\"</code>. - Caso 3: Parpadeo autom\u00e1tico del LED en intervalos. - Evidencias en fotos del c\u00f3digo y videos del funcionamiento.  </p> <p>No incluye: - Control de m\u00faltiples LEDs o actuadores. - Desarrollo de aplicaciones m\u00f3viles personalizadas. - Integraci\u00f3n con plataformas IoT externas.  </p>"},{"location":"control%20de%20led%20con%20ESP32/#4-requisitos","title":"4) Requisitos","text":"<p>Software: - Arduino IDE con soporte para ESP32. - Librer\u00edas necesarias para comunicaci\u00f3n Bluetooth. - Monitor serie o aplicaci\u00f3n de terminal Bluetooth.  </p> <p>Hardware: - ESP32. - LED + resistencia limitadora (330 \u03a9 a 820 \u03a9). - Pulsador (bot\u00f3n). - Protoboard y cables de conexi\u00f3n. - Fuente de alimentaci\u00f3n USB (5 V).  </p> <p>Conocimientos previos: - Programaci\u00f3n b\u00e1sica en Arduino/ESP32. - Manejo de entradas digitales (lectura de botones). - Control de salidas digitales (encendido y apagado de LED). - Conceptos de comunicaci\u00f3n b\u00e1sica v\u00eda Bluetooth. - Uso de funciones de temporizaci\u00f3n (<code>delay</code>, <code>millis</code>, etc.) para parpadeo en intervalos.</p>"},{"location":"control%20de%20led%20con%20ESP32/#programas-esp32-control-de-led","title":"Programas ESP32 - Control de LED","text":"<p>Este repositorio contiene tres ejemplos b\u00e1sicos para controlar un LED con un ESP32: 1. Encender y apagar con un bot\u00f3n f\u00edsico. 2. Encender y apagar mediante comandos enviados por Bluetooth. 3. Hacer parpadear el LED en intervalos de 2 segundos.  </p>"},{"location":"control%20de%20led%20con%20ESP32/#1-control-con-boton","title":"1. Control con Bot\u00f3n","text":"<pre><code>const int led = 33;\nconst int btn = 27;\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(led, OUTPUT);\n  pinMode(btn, INPUT);\n}\n\nvoid loop() {\n  int estado = digitalRead(btn);\n  if (estado == 1) {\n    digitalWrite(led, 1);  // LED encendido mientras el bot\u00f3n est\u00e9 presionado\n  } else {\n    digitalWrite(led, 0);  // LED apagado cuando no se presiona\n  }\n}\n</code></pre>"},{"location":"control%20de%20led%20con%20ESP32/#2-control-con-bluetooth","title":"2. Control con Bluetooth","text":"<pre><code>#include \"BluetoothSerial.h\"\nBluetoothSerial SerialBT;\n\nconst int led = 33;\n\nvoid setup() {\n  Serial.begin(115200);\n  SerialBT.begin(\"ESP32-de-los-PAPITOS\"); // Nombre del dispositivo Bluetooth\n  pinMode(led, OUTPUT);\n}\n\nvoid loop() {\n  if (SerialBT.available()) {\n    String mensaje = SerialBT.readString();\n    Serial.println(\"Recibido: \" + mensaje);\n\n    if (mensaje == \"on\") {\n      digitalWrite(led, 1);   // LED encendido por comando\n    } \n    else if (mensaje == \"off\") {\n      digitalWrite(led, 0);   // LED apagado por comando\n    }\n  }\n  delay(1000);\n}\n</code></pre>"},{"location":"control%20de%20led%20con%20ESP32/#3-intervalos-de-parpadeo","title":"3. Intervalos de Parpadeo","text":"<pre><code>const int led = 33;\n\nvoid setup() {\n  pinMode(led, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(led, HIGH);  // LED encendido\n  delay(2000);              // Espera 2 segundos\n  digitalWrite(led, LOW);   // LED apagado\n  delay(2000);              // Espera 2 segundos\n}\n</code></pre>"},{"location":"control%20de%20led%20con%20ESP32/#videos","title":"Videos","text":""},{"location":"control%20de%20led%20con%20ESP32/#control-solo-por-esp-32","title":"Control, solo por ESP 32","text":"Tu navegador no soporta la reproducci\u00f3n de video."},{"location":"control%20de%20led%20con%20ESP32/#control-por-bluetooth","title":"Control por bluetooth","text":"Tu navegador no soporta la reproducci\u00f3n de video."},{"location":"control%20de%20led%20con%20ESP32/#control-por-boton","title":"Control por bot\u00f3n","text":"Tu navegador no soporta la reproducci\u00f3n de video."}]}